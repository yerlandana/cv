<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><title>Lydia Hallie | Talks | Rendering Patterns</title><meta property="og:image" content="https://lydiahallie.io/images/talks/advanced-rendering-patterns/og.png"><meta property="og:title" content="Talks | Rendering Patterns"><meta property="og:description" content="Using the right rendering and fetching techniques can drastically improve your apps performance. Learn more about the rendering patterns, their use cases, and tradeoffs."><meta property="og:url" content="https://lydiahallie.ioundefined"><meta property="og:type" content="article"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="Using the right rendering and fetching techniques can drastically improve your apps performance. Learn more about the rendering patterns, their use cases, and tradeoffs."><meta name="author" content="Lydia Hallie"><meta property="og:locale" content="en_US"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content="@lydiahallie"><meta name="twitter:creator" content="@lydiahallie"><meta name="twitter:title" content="Talks | Rendering Patterns"><meta name="twitter:description" content="Using the right rendering and fetching techniques can drastically improve your apps performance. Learn more about the rendering patterns, their use cases, and tradeoffs."><meta name="twitter:image" content="https://lydiahallie.io/images/talks/advanced-rendering-patterns/og.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="692"><link rel="preload" as="image" imagesrcset="/_next/image?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F2.png&amp;w=640&amp;q=75 640w, /_next/image?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F2.png&amp;w=750&amp;q=75 750w, /_next/image?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F2.png&amp;w=828&amp;q=75 828w, /_next/image?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F2.png&amp;w=1080&amp;q=75 1080w, /_next/image?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F2.png&amp;w=1200&amp;q=75 1200w, /_next/image?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F2.png&amp;w=1920&amp;q=75 1920w, /_next/image?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F2.png&amp;w=2048&amp;q=75 2048w, /_next/image?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F2.png&amp;w=3840&amp;q=75 3840w" imagesizes="100vw"><link rel="preload" as="image" imagesrcset="/_next/image?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F3.png&amp;w=640&amp;q=75 640w, /_next/image?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F3.png&amp;w=750&amp;q=75 750w, /_next/image?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F3.png&amp;w=828&amp;q=75 828w, /_next/image?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F3.png&amp;w=1080&amp;q=75 1080w, /_next/image?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F3.png&amp;w=1200&amp;q=75 1200w, /_next/image?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F3.png&amp;w=1920&amp;q=75 1920w, /_next/image?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F3.png&amp;w=2048&amp;q=75 2048w, /_next/image?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F3.png&amp;w=3840&amp;q=75 3840w" imagesizes="100vw"><link rel="preload" as="image" imagesrcset="/_next/image?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F4.1.png&amp;w=640&amp;q=75 640w, /_next/image?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F4.1.png&amp;w=750&amp;q=75 750w, /_next/image?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F4.1.png&amp;w=828&amp;q=75 828w, /_next/image?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F4.1.png&amp;w=1080&amp;q=75 1080w, /_next/image?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F4.1.png&amp;w=1200&amp;q=75 1200w, /_next/image?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F4.1.png&amp;w=1920&amp;q=75 1920w, /_next/image?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F4.1.png&amp;w=2048&amp;q=75 2048w, /_next/image?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F4.1.png&amp;w=3840&amp;q=75 3840w" imagesizes="100vw"><meta name="next-head-count" content="22"><link rel="icon" type="image/x-icon" href="../favicon.png"><meta name="robots" content="follow, index"><meta property="og:site_name" content="Lydia Hallie"><meta property="og:title" content="Lydia Hallie"><meta property="og:image" content="https://lydiahallie.io/ogimage.png"><meta property="og:description" content="I&#x27;m Lydia, a Staff Developer Advocate at Vercel, in JavaScript, TypeScript, GraphQL, Web Performance, and Cloud technologies. I like to make computer science concepts easier for anyone who&#x27;s interested in tech, by writing approachable articles on technical content through visualizations!"><meta name="description" content="Lydia Hallie is a Staff Developer Advocate at Vercel, specialized in JavaScript, TypeScript, GraphQL, Web Performance, and Cloud technologies."><meta name="keywords" content="Lydia Hallie, Avocoder, JavaScript, TypeScript, JS, GraphQL, software, software engineer, code, coding"><meta name="theme-color" content="#13111A"><link rel="preconnect" href="https://res.cloudinary.com"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><script async="" src="../gtag/js?id=&lt;Your_tracking_ID&gt;"></script><script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());
            gtag('config', '<Your_tracking_ID>', {
              page_path: window.location.pathname,
            });
          </script><link rel="preload" href="../_next/static/css/cf56a14e94e3c8b6.css" as="style"><link rel="stylesheet" href="../_next/static/css/cf56a14e94e3c8b6.css" data-n-g=""><link rel="preload" href="../_next/static/css/f302cdb0c3958e3e.css" as="style"><link rel="stylesheet" href="../_next/static/css/f302cdb0c3958e3e.css" data-n-p=""><noscript data-n-css=""></noscript><script defer="" nomodule="" src="../_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="../_next/static/chunks/webpack-9b312e20a4e32339.js" defer=""></script><script src="../_next/static/chunks/framework-a87821de553db91d.js" defer=""></script><script src="../_next/static/chunks/main-fc7d2f0e2098927e.js" defer=""></script><script src="../_next/static/chunks/pages/_app-81be0ee9e317eb1e.js" defer=""></script><script src="../_next/static/chunks/547-cd310fdf06a1d81c.js" defer=""></script><script src="../_next/static/chunks/301-9ddc85d5ead33612.js" defer=""></script><script src="../_next/static/chunks/pages/%5Btype%5D/%5Bpost%5D-d5888ece0162fcff.js" defer=""></script><script src="../_next/static/GFd_W0mTx3KmMMLu9UgcV/_buildManifest.js" defer=""></script><script src="../_next/static/GFd_W0mTx3KmMMLu9UgcV/_ssgManifest.js" defer=""></script><script src="../_next/static/GFd_W0mTx3KmMMLu9UgcV/_middlewareManifest.js" defer=""></script><style id="__jsx-2cb62b8d759e2a53">.lazyload-wrapper.jsx-2cb62b8d759e2a53{margin:0px -30px;margin-bottom:50px;border-style:solid;border-width:2px;border-color:rgba(255,255,255,.16);-webkit-border-radius:7px;-moz-border-radius:7px;border-radius:7px;-webkit-box-shadow:0 10px 24px 0 rgb(0 0 0/65%)!important;-moz-box-shadow:0 10px 24px 0 rgb(0 0 0/65%)!important;box-shadow:0 10px 24px 0 rgb(0 0 0/65%)!important}video.jsx-2cb62b8d759e2a53{border-style:solid;border-width:2px;border-color:rgba(255,255,255,.16);-webkit-border-radius:7px;-moz-border-radius:7px;border-radius:7px;-webkit-box-shadow:0 10px 24px 0 rgb(0 0 0/65%)!important;-moz-box-shadow:0 10px 24px 0 rgb(0 0 0/65%)!important;box-shadow:0 10px 24px 0 rgb(0 0 0/65%)!important}</style></head><body><div id="__next"><nav class="border-b-2 fixed w-screen" style="border-color:#1d1a27;background-color:#13111A;z-index:100;position:relative"><div class="max-w-7xl mx-auto py-2 sm:py-1 lg:py-1 container-default"><div class="relative flex items-center justify-between h-12"><div class="flex items-center px-2 lg:px-0"><div class="flex-shrink-0" style="cursor:pointer" href="../index.htm"><img class="block lg:hidden h-12 w-auto" src="../myname.png" alt="Logo"><img class="hidden lg:block h-16 w-auto" src="../myname.png" alt="Logo"></div></div></div></div></nav><div class="Home_container__bCOhY"><section class="styles_section__2xJbu"><div class="styles_post-container__WsAnW"><div style="opacity:1" class="styles_card-post-item-about-wrapper__CiyXF"><div class="styles_card-post-item-about-content__lWKis"><div class="styles_card-post-item-about-icon__lkcLB"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%2718%27%20height=%2718%27/%3e"></span><img alt="Date" srcset="../icons/date.svg 1x, ../icons/date.svg 2x" src="../icons/date.svg" decoding="async" data-nimg="intrinsic" class="styles_img-logo__scMsO" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%"></span></div>Last updated: <!-- -->May 6th, 2022<!-- --></div><div class="styles_card-post-item-about-content__lWKis"><div class="styles_card-post-item-about-icon__lkcLB"><span style="box-sizing:border-box;display:inline-block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative;max-width:100%"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;max-width:100%"><img style="display:block;max-width:100%;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0" alt="" aria-hidden="true" src="data:image/svg+xml,%3csvg%20xmlns=%27http://www.w3.org/2000/svg%27%20version=%271.1%27%20width=%2718%27%20height=%2718%27/%3e"></span><img alt="Clock" srcset="../icons/clock.svg 1x, ../icons/clock.svg 2x" src="../icons/clock.svg" decoding="async" data-nimg="intrinsic" class="styles_img-logo__scMsO" style="position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%"></span></div><div>27 min read</div></div></div><h1 class="styles_title__5zTQ_">Talks | Rendering Patterns</h1></div><div class="styles_post-container__WsAnW"><blockquote>
<!-- --><p>This article is a transcript with slides of a talk I gave at Reactathon on May 3rd, 2022.</p>
<!-- --><div class="lazyload-wrapper "><div style="height:315px" class="lazyload-placeholder"></div></div>
<!-- --></blockquote>
<!-- --><p>Building on the web has never been more powerful than it is in 2022, and which patterns make the most sense for your use case can give your application huge performance benefits.</p>
<!-- --><p>Now I&#x27;m not here to talk bad about certain patterns and praise others, it&#x27;s just here to cover some common patterns we see nowadays and <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">their tradeoffs for specific use cases</strong>!<!-- --></p>
<!-- --><style>
                      .image-container {
                        width: 110%;
                        margin-bottom: 50px;
                      }

                      @media screen and (max-width: 767px) {
                        .image-container {
                          width: 95vw;
                        }
                      }

                    </style><div class="image-container"><span style="box-sizing:border-box;display:block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;padding-top:55.74468085106383%"></span><img alt="Flow chart" sizes="100vw" srcset="../_next/2-1.png 640w?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F2.png&amp;w=640&amp;q=75 640w, ../_next/2-2.png 750we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F2.png&amp;w=750&amp;q=75 750w, ../_next/2-3.png 828we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F2.png&amp;w=828&amp;q=75 828w, ../_next/2-4.png 1080we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F2.png&amp;w=1080&amp;q=75 1080w, ../_next/2-5.png 1200we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F2.png&amp;w=1200&amp;q=75 1200w, ../_next/2-6.png 1920we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F2.png&amp;w=1920&amp;q=75 1920w, ../_next/2-7.png 2048we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F2.png&amp;w=2048&amp;q=75 2048w, ../_next/2.png 3840we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F2.png&amp;w=3840&amp;q=75 3840w" src="../_next/2.png?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F2.png&amp;w=3840&amp;q=75" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%"></span></div>
<!-- --><p>Ideally, we just want to develop, preview, ship, impress users, and change the world with our revolutionary ideas.</p>
<!-- --><style>
                      .image-container {
                        width: 110%;
                        margin-bottom: 50px;
                      }

                      @media screen and (max-width: 767px) {
                        .image-container {
                          width: 95vw;
                        }
                      }

                    </style><div class="image-container"><span style="box-sizing:border-box;display:block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;padding-top:55.74468085106383%"></span><img alt="Flow chart" sizes="100vw" srcset="../_next/3.png 640w?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F3.png&amp;w=640&amp;q=75 640w, ../_next/3-1.png 750we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F3.png&amp;w=750&amp;q=75 750w, ../_next/3-2.png 828we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F3.png&amp;w=828&amp;q=75 828w, ../_next/3-3.png 1080we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F3.png&amp;w=1080&amp;q=75 1080w, ../_next/3-4.png 1200we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F3.png&amp;w=1200&amp;q=75 1200w, ../_next/3-5.png 1920we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F3.png&amp;w=1920&amp;q=75 1920w, ../_next/3-6.png 2048we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F3.png&amp;w=2048&amp;q=75 2048w, ../_next/%252Fimages%252Ftalks%252Fadvanced-rendering-patterns%252F3.png 3840we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F3.png&amp;w=3840&amp;q=75 3840w" src="../_next/%252Fimages%252Ftalks%252Fadvanced-rendering-patterns%252F3.png?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F3.png&amp;w=3840&amp;q=75" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%"></span></div>
<!-- --><p>Unfortunately, in most cases, it doesn&#x27;t quite end up this way. We might accidentally introduce really <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">long build times</strong>, <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">frustrate our users</strong> because the website loads real slow or has a jumpy UI, and get with a <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">huge server bill</strong> at the end of the month for a project that didn&#x27;t even gain traction, as the website never got a great SEO due to bad performance.<!-- --></p>
<!-- --><p>Although our idea might have changed the world, the way that we architected our project prevented this from ever happening!</p>
<!-- --><style>
                      .image-container {
                        width: 110%;
                        margin-bottom: 50px;
                      }

                      @media screen and (max-width: 767px) {
                        .image-container {
                          width: 95vw;
                        }
                      }

                    </style><div class="image-container"><span style="box-sizing:border-box;display:block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;padding-top:55.74468085106383%"></span><img alt="Flow chart" sizes="100vw" srcset="../_next/4.png 640w?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F4.1.png&amp;w=640&amp;q=75 640w, ../_next/4-1.png 750we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F4.1.png&amp;w=750&amp;q=75 750w, ../_next/4-2.png 828we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F4.1.png&amp;w=828&amp;q=75 828w, ../_next/4-3.png 1080we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F4.1.png&amp;w=1080&amp;q=75 1080w, ../_next/4-4.png 1200we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F4.1.png&amp;w=1200&amp;q=75 1200w, ../_next/4-5.png 1920we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F4.1.png&amp;w=1920&amp;q=75 1920w, ../_next/4-6.png 2048we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F4.1.png&amp;w=2048&amp;q=75 2048w, ../_next/%252Fimages%252Ftalks%252Fadvanced-rendering-patterns%252F4.png 3840we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F4.1.png&amp;w=3840&amp;q=75 3840w" src="../_next/%252Fimages%252Ftalks%252Fadvanced-rendering-patterns%252F4.png?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F4.1.png&amp;w=3840&amp;q=75" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%"></span></div>
<!-- --><p>So... what can we do about this?</p>
<!-- --><p>We have to start implementing the right rendering patterns in our applications! Knowing how to apply these techniques can massively improve your app&#x27;s performance, giving you a great product to share with the world.</p>
<!-- --><div class="styles_divider__vbkkn"></div>
<!-- --><p>Usually when we talk about web performance, we think about optimizing for the <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">Core Web Vitals</strong>.<!-- --></p>
<!-- --><style>
                      .image-container {
                        width: 110%;
                        margin-bottom: 50px;
                      }

                      @media screen and (max-width: 767px) {
                        .image-container {
                          width: 95vw;
                        }
                      }

                    </style><div class="image-container"><span style="box-sizing:border-box;display:block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;padding-top:55.74468085106383%"></span><img alt="Flow chart" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%"><noscript><img alt="Flow chart" sizes="100vw" srcset="../_next/1-1.png 640w?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F1.png&amp;w=640&amp;q=75 640w, ../_next/1-2.png 750we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F1.png&amp;w=750&amp;q=75 750w, ../_next/1-3.png 828we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F1.png&amp;w=828&amp;q=75 828w, ../_next/1-4.png 1080we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F1.png&amp;w=1080&amp;q=75 1080w, ../_next/1-5.png 1200we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F1.png&amp;w=1200&amp;q=75 1200w, ../_next/1-6.png 1920we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F1.png&amp;w=1920&amp;q=75 1920w, ../_next/1-7.png 2048we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F1.png&amp;w=2048&amp;q=75 2048w, ../_next/1.png 3840we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F1.png&amp;w=3840&amp;q=75 3840w" src="../_next/1.png?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F1.png&amp;w=3840&amp;q=75" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%" loading="lazy"></noscript></span></div>
<!-- --><p>These are a <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">set of useful measurements</strong> that tell us how well our site performs, for example the <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">TTFB</strong> measures the time it takes for the server to respond with the initial data, and the <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">FCP</strong> measures how quickly your users see useful content on their screen for the first time, and so on, I won&#x27;t go over all of these right now.<!-- --></p>
<!-- --><p>If we want to have a website with <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">great user experience and optimal SEO</strong>, we have to start caring about optimizing for these measurements.<!-- --></p>
<!-- --><style>
                      .image-container {
                        width: 110%;
                        margin-bottom: 50px;
                      }

                      @media screen and (max-width: 767px) {
                        .image-container {
                          width: 95vw;
                        }
                      }

                    </style><div class="image-container"><span style="box-sizing:border-box;display:block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;padding-top:55.74468085106383%"></span><img alt="Flow chart" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%"><noscript><img alt="Flow chart" sizes="100vw" srcset="../_next/5-1.png 640w?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F5.png&amp;w=640&amp;q=75 640w, ../_next/5-2.png 750we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F5.png&amp;w=750&amp;q=75 750w, ../_next/5-3.png 828we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F5.png&amp;w=828&amp;q=75 828w, ../_next/5-4.png 1080we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F5.png&amp;w=1080&amp;q=75 1080w, ../_next/5-5.png 1200we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F5.png&amp;w=1200&amp;q=75 1200w, ../_next/5-6.png 1920we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F5.png&amp;w=1920&amp;q=75 1920w, ../_next/5-7.png 2048we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F5.png&amp;w=2048&amp;q=75 2048w, ../_next/5.png 3840we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F5.png&amp;w=3840&amp;q=75 3840w" src="../_next/5.png?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F5.png&amp;w=3840&amp;q=75" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%" loading="lazy"></noscript></span></div>
<!-- --><p>But that’s not all,  we also want to have the best developer experience!</p>
<!-- --><p>We want a project with <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">short build times</strong> to be able to quickly iterate, <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">low server costs</strong> so we don’t go bankrupt, show <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">dynamic content</strong> in a performant way if needed, and generally <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">no scalability issues</strong> further down the line when our website goes viral.<!-- --></p>
<!-- --><style>
                      .image-container {
                        width: 110%;
                        margin-bottom: 50px;
                      }

                      @media screen and (max-width: 767px) {
                        .image-container {
                          width: 95vw;
                        }
                      }

                    </style><div class="image-container"><span style="box-sizing:border-box;display:block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;padding-top:55.74468085106383%"></span><img alt="Flow chart" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%"><noscript><img alt="Flow chart" sizes="100vw" srcset="../_next/6-1.png 640w?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F6.png&amp;w=640&amp;q=75 640w, ../_next/6-2.png 750we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F6.png&amp;w=750&amp;q=75 750w, ../_next/6-3.png 828we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F6.png&amp;w=828&amp;q=75 828w, ../_next/6-4.png 1080we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F6.png&amp;w=1080&amp;q=75 1080w, ../_next/6-5.png 1200we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F6.png&amp;w=1200&amp;q=75 1200w, ../_next/6-6.png 1920we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F6.png&amp;w=1920&amp;q=75 1920w, ../_next/6-7.png 2048we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F6.png&amp;w=2048&amp;q=75 2048w, ../_next/6.png 3840we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F6.png&amp;w=3840&amp;q=75 3840w" src="../_next/6.png?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F6.png&amp;w=3840&amp;q=75" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%" loading="lazy"></noscript></span></div>
<!-- --><p>Although this seems like a lot to keep in mind, using the right rendering technique can really help you out here to create a great user and developer experience.</p>
<!-- --><div class="styles_divider__vbkkn"></div>
<!-- --><p>Now that we know why rendering patterns are imporant, how do you know which ones make the most sense for your website? Or if you&#x27;re using Vercel, you can even choose this on a per-page basis, so which one makes the most sense for that specific page?</p>
<!-- --><p>Spending one minute on Google or on tech twitter can already feel pretty overwhelming with all new terms, abbreviations and the latest trendy ways to render data, and people’s opinion on them.</p>
<!-- --><p>All patterns out there have their use case, there is not one pattern that’s better than the others, as long as you know their tradeoffs.</p>
<!-- --><div class="styles_divider__vbkkn"></div>
<!-- --><style>
                      .image-container {
                        width: 110%;
                        margin-bottom: 50px;
                      }

                      @media screen and (max-width: 767px) {
                        .image-container {
                          width: 95vw;
                        }
                      }

                    </style><div class="image-container"><span style="box-sizing:border-box;display:block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;padding-top:55.74468085106383%"></span><img alt="Flow chart" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%"><noscript><img alt="Flow chart" sizes="100vw" srcset="../_next/img1-1.png 640w?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2Fimg1.png&amp;w=640&amp;q=75 640w, ../_next/img1-2.png 750we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2Fimg1.png&amp;w=750&amp;q=75 750w, ../_next/img1-3.png 828we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2Fimg1.png&amp;w=828&amp;q=75 828w, ../_next/img1-4.png 1080we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2Fimg1.png&amp;w=1080&amp;q=75 1080w, ../_next/img1-5.png 1200we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2Fimg1.png&amp;w=1200&amp;q=75 1200w, ../_next/img1-6.png 1920we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2Fimg1.png&amp;w=1920&amp;q=75 1920w, ../_next/img1-7.png 2048we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2Fimg1.png&amp;w=2048&amp;q=75 2048w, ../_next/img1.png 3840we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2Fimg1.png&amp;w=3840&amp;q=75 3840w" src="../_next/img1.png?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2Fimg1.png&amp;w=3840&amp;q=75" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%" loading="lazy"></noscript></span></div>
<!-- --><p>First, let’s talk about a pattern that may seem very basic and straight-forward, namely <!-- --><strong style="color:#EDB658;background:-webkit-linear-gradient(45deg, #EDB658, #E7719B);-webkit-background-clip:text;-webkit-text-fill-color:transparent">Static Rendering</strong>.<!-- --></p>
<!-- --><p>Although it might seem simple, there are many variations to static rendering to serve a lot of different use cases. Static rendering is popular pattern as it comes with so many performance benefits.</p>
<!-- --><p>With static rendering, the <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">entire HTML gets generated at build time</strong>.<!-- --></p>
<!-- --><p>Since the files are static, they’re <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">easily cacheable by a CDN</strong>, or on Vercel by the Edge Network. This makes it possible to get <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">extremely fast responses</strong>, since the CDN can quickly return the cached file instead of having to request it from the origin server.<!-- --></p>
<!-- --><p>There are many variations to static rendering to serve a lot of different use cases.</p>
<!-- --><div class="styles_divider__vbkkn"></div>
<!-- --><style>
                      .image-container {
                        width: 110%;
                        margin-bottom: 50px;
                      }

                      @media screen and (max-width: 767px) {
                        .image-container {
                          width: 95vw;
                        }
                      }

                    </style><div class="image-container"><span style="box-sizing:border-box;display:block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;padding-top:55.74468085106383%"></span><img alt="Flow chart" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%"><noscript><img alt="Flow chart" sizes="100vw" srcset="../_next/img1-1.jpg 640w?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2Fimg1.jpeg&amp;w=640&amp;q=75 640w, ../_next/img1-2.jpg 750we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2Fimg1.jpeg&amp;w=750&amp;q=75 750w, ../_next/img1-3.jpg 828we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2Fimg1.jpeg&amp;w=828&amp;q=75 828w, ../_next/img1-4.jpg 1080we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2Fimg1.jpeg&amp;w=1080&amp;q=75 1080w, ../_next/img1-5.jpg 1200we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2Fimg1.jpeg&amp;w=1200&amp;q=75 1200w, ../_next/img1-6.jpg 1920we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2Fimg1.jpeg&amp;w=1920&amp;q=75 1920w, ../_next/img1-7.jpg 2048we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2Fimg1.jpeg&amp;w=2048&amp;q=75 2048w, ../_next/img1.jpg 3840we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2Fimg1.jpeg&amp;w=3840&amp;q=75 3840w" src="../_next/img1.jpg?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2Fimg1.jpeg&amp;w=3840&amp;q=75" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%" loading="lazy"></noscript></span></div>
<!-- --><p>First up is <!-- --><strong style="color:#EDB658;background:-webkit-linear-gradient(45deg, #EDB658, #E7719B);-webkit-background-clip:text;-webkit-text-fill-color:transparent">Plain Static Rendering</strong> (<!-- --><em>I&#x27;m just calling it plain static rendering since I couldn&#x27;t really think of a better term lol, not sure if there is one</em>).<!-- --></p>
<!-- --><p><strong style="color:#EDB658;background:-webkit-linear-gradient(45deg, #EDB658, #E7719B);-webkit-background-clip:text;-webkit-text-fill-color:transparent">Plain Static Rendering</strong> is a technique we can use for <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">very non-dynamic pages</strong>, such as the landing page of this fake demo real estate website.<!-- --></p>
<!-- --><p>This page is absolutely perfect for <!-- --><strong style="color:#EDB658;background:-webkit-linear-gradient(45deg, #EDB658, #E7719B);-webkit-background-clip:text;-webkit-text-fill-color:transparent">static rendering</strong> as it just shows the <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">same data for everyone globally</strong>. We aren’t fetching any data or showing any personalized components.<!-- --></p>
<!-- --><div class="jsx-2cb62b8d759e2a53"><div class="lazyload-wrapper styles_lazyload-wrapper__iNCqt"><div class="video-placeholder"><p>Loading Video...</p><p id="sub"><a href="https://res.cloudinary.com/dq8xfyhu4/video/upload/v1609691928/CS%20Visualized//CS%20Visualized/Screen_Recording_2022-05-05_at_10.10.58_AM_umtlyl.jpg" target="_blank" rel="noreferrer">If it takes too long, you can click here to see the video in a new tab.</a></p></div></div></div>
<!-- --><p>When we deploy this, in this case to Vercel, the HTML gets generated for the pages, and persisted to static storage.</p>
<!-- --><div class="jsx-2cb62b8d759e2a53"><div class="lazyload-wrapper styles_lazyload-wrapper__iNCqt"><div class="video-placeholder"><p>Loading Video...</p><p id="sub"><a href="https://res.cloudinary.com/dq8xfyhu4/video/upload/v1609691928/CS%20Visualized//CS%20Visualized/Screen_Recording_2022-05-05_at_10.18.37_AM_bhybvb.jpg" target="_blank" rel="noreferrer">If it takes too long, you can click here to see the video in a new tab.</a></p></div></div></div>
<!-- --><p>When a user visits the website, a request is made to the server.</p>
<!-- --><p>The server can quickly return the pre-generated HTML to the client, and as it gets returned, the Edge location closest to the user caches the response.</p>
<!-- --><p>The browser renders the HTML, and requests a JavaScript bundle to hydrate the page. (<!-- --><em>Hydration is the process of binding event handlers to the HTML elements to make them interactive</em>)<!-- --></p>
<!-- --><style>
                      .image-container {
                        width: 110%;
                        margin-bottom: 50px;
                      }

                      @media screen and (max-width: 767px) {
                        .image-container {
                          width: 95vw;
                        }
                      }

                    </style><div class="image-container"><span style="box-sizing:border-box;display:block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;padding-top:55.74468085106383%"></span><img alt="Flow chart" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%"><noscript><img alt="Flow chart" sizes="100vw" srcset="../_next/7-1.png 640w?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F7.png&amp;w=640&amp;q=75 640w, ../_next/7-2.png 750we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F7.png&amp;w=750&amp;q=75 750w, ../_next/7-3.png 828we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F7.png&amp;w=828&amp;q=75 828w, ../_next/7-4.png 1080we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F7.png&amp;w=1080&amp;q=75 1080w, ../_next/7-5.png 1200we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F7.png&amp;w=1200&amp;q=75 1200w, ../_next/7-6.png 1920we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F7.png&amp;w=1920&amp;q=75 1920w, ../_next/7-7.png 2048we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F7.png&amp;w=2048&amp;q=75 2048w, ../_next/7.png 3840we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F7.png&amp;w=3840&amp;q=75 3840w" src="../_next/7.png?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F7.png&amp;w=3840&amp;q=75" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%" loading="lazy"></noscript></span></div>
<!-- --><p>From a performance perspective, this is a great approach!</p>
<!-- --><p>We can have an <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">extremely quick TTFB</strong> since the server already contains the pre-generated HTML, and the browser can quickly render something to the screen, resulting in a <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">fast FCP and LCP</strong>.  We also <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">don’t have to worry about layout shift</strong> since we’re not dynamically loading components.<!-- --></p>
<!-- --><style>
                      .image-container {
                        width: 110%;
                        margin-bottom: 50px;
                      }

                      @media screen and (max-width: 767px) {
                        .image-container {
                          width: 95vw;
                        }
                      }

                    </style><div class="image-container"><span style="box-sizing:border-box;display:block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;padding-top:55.74468085106383%"></span><img alt="Flow chart" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%"><noscript><img alt="Flow chart" sizes="100vw" srcset="../_next/8-1.png 640w?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F8.png&amp;w=640&amp;q=75 640w, ../_next/8-2.png 750we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F8.png&amp;w=750&amp;q=75 750w, ../_next/8-3.png 828we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F8.png&amp;w=828&amp;q=75 828w, ../_next/8-4.png 1080we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F8.png&amp;w=1080&amp;q=75 1080w, ../_next/8-5.png 1200we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F8.png&amp;w=1200&amp;q=75 1200w, ../_next/8-6.png 1920we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F8.png&amp;w=1920&amp;q=75 1920w, ../_next/8-7.png 2048we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F8.png&amp;w=2048&amp;q=75 2048w, ../_next/8.png 3840we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F8.png&amp;w=3840&amp;q=75 3840w" src="../_next/8.png?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F8.png&amp;w=3840&amp;q=75" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%" loading="lazy"></noscript></span></div>
<!-- --><p><strong style="color:#EDB658;background:-webkit-linear-gradient(45deg, #EDB658, #E7719B);-webkit-background-clip:text;-webkit-text-fill-color:transparent">Plain Static Rendering</strong> is great for your Core Web Vitals, especially in combination with a CDN. However, in most cases, we&#x27;ll probably want to show some dynamic data.<!-- --></p>
<!-- --><p>Say that instead of showing some services here, we actually want to show some recent listings. We <!-- --><em>could</em> just hard-code that data right in the page, but in reality we’re probably using some data provider to get our listings from.<!-- --></p>
<!-- --><div class="styles_divider__vbkkn"></div>
<!-- --><style>
                      .image-container {
                        width: 110%;
                        margin-bottom: 50px;
                      }

                      @media screen and (max-width: 767px) {
                        .image-container {
                          width: 95vw;
                        }
                      }

                    </style><div class="image-container"><span style="box-sizing:border-box;display:block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;padding-top:55.74468085106383%"></span><img alt="Flow chart" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%"><noscript><img alt="Flow chart" sizes="100vw" srcset="../_next/9-1.png 640w?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F9.png&amp;w=640&amp;q=75 640w, ../_next/9-2.png 750we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F9.png&amp;w=750&amp;q=75 750w, ../_next/9-3.png 828we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F9.png&amp;w=828&amp;q=75 828w, ../_next/9-4.png 1080we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F9.png&amp;w=1080&amp;q=75 1080w, ../_next/9-5.png 1200we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F9.png&amp;w=1200&amp;q=75 1200w, ../_next/9-6.png 1920we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F9.png&amp;w=1920&amp;q=75 1920w, ../_next/9-7.png 2048we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F9.png&amp;w=2048&amp;q=75 2048w, ../_next/9.png 3840we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F9.png&amp;w=3840&amp;q=75 3840w" src="../_next/9.png?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F9.png&amp;w=3840&amp;q=75" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%" loading="lazy"></noscript></span></div>
<!-- --><p>One approach we can take here, is to use <!-- --><strong style="color:#EDB658;background:-webkit-linear-gradient(45deg, #EDB658, #E7719B);-webkit-background-clip:text;-webkit-text-fill-color:transparent">Static Rendering with Client-Side</strong> <!-- --><span style="background-color:rgb(49 48 52 / 50%);padding:0.2rem 0.4rem;font-size:85%;margin:0.2rem;border-radius:0.2em;font-family:Menlo;font-weight:bolder"> <!-- -->fetch<!-- --></span>. This is usually a great pattern for pages that contain <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">data that should be updated on every request</strong>.<!-- --></p>
<!-- --><style>
                      .image-container {
                        width: 110%;
                        margin-bottom: 50px;
                      }

                      @media screen and (max-width: 767px) {
                        .image-container {
                          width: 95vw;
                        }
                      }

                    </style><div class="image-container"><span style="box-sizing:border-box;display:block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;padding-top:55.74468085106383%"></span><img alt="Flow chart" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%"><noscript><img alt="Flow chart" sizes="100vw" srcset="../_next/10-1.png 640w?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F10.png&amp;w=640&amp;q=75 640w, ../_next/10-2.png 750we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F10.png&amp;w=750&amp;q=75 750w, ../_next/10-3.png 828we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F10.png&amp;w=828&amp;q=75 828w, ../_next/10-4.png 1080we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F10.png&amp;w=1080&amp;q=75 1080w, ../_next/10-5.png 1200we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F10.png&amp;w=1200&amp;q=75 1200w, ../_next/10-6.png 1920we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F10.png&amp;w=1920&amp;q=75 1920w, ../_next/10-7.png 2048we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F10.png&amp;w=2048&amp;q=75 2048w, ../_next/10.png 3840we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F10.png&amp;w=3840&amp;q=75 3840w" src="../_next/10.png?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F10.png&amp;w=3840&amp;q=75" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%" loading="lazy"></noscript></span></div>
<!-- --><p>We can statically render the website like we did before,  and fetch the data using for example SWR on the client as soon as the page has loaded. While the data is being fetched, we’ll show a skeleton component.</p>
<!-- --><style>
                      .image-container {
                        width: 110%;
                        margin-bottom: 50px;
                      }

                      @media screen and (max-width: 767px) {
                        .image-container {
                          width: 95vw;
                        }
                      }

                    </style><div class="image-container"><span style="box-sizing:border-box;display:block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;padding-top:55.74468085106383%"></span><img alt="Flow chart" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%"><noscript><img alt="Flow chart" sizes="100vw" srcset="../_next/11-1.png 640w?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F11.png&amp;w=640&amp;q=75 640w, ../_next/11-2.png 750we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F11.png&amp;w=750&amp;q=75 750w, ../_next/11-3.png 828we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F11.png&amp;w=828&amp;q=75 828w, ../_next/11-4.png 1080we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F11.png&amp;w=1080&amp;q=75 1080w, ../_next/11-5.png 1200we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F11.png&amp;w=1200&amp;q=75 1200w, ../_next/11-6.png 1920we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F11.png&amp;w=1920&amp;q=75 1920w, ../_next/11-7.png 2048we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F11.png&amp;w=2048&amp;q=75 2048w, ../_next/11.png 3840we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F11.png&amp;w=3840&amp;q=75 3840w" src="../_next/11.png?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F11.png&amp;w=3840&amp;q=75" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%" loading="lazy"></noscript></span></div>
<!-- --><p>We also need create a custom API route to fetch the data from. Within the API route, we retrieve the data from our CMS, and return this data.</p>
<!-- --><div class="jsx-2cb62b8d759e2a53"><div class="lazyload-wrapper styles_lazyload-wrapper__iNCqt"><div class="video-placeholder"><p>Loading Video...</p><p id="sub"><a href="https://res.cloudinary.com/dq8xfyhu4/video/upload/v1609691928/CS%20Visualized//CS%20Visualized/Screen_Recording_2022-05-05_at_2.55.30_PM_r0jvez.jpg" target="_blank" rel="noreferrer">If it takes too long, you can click here to see the video in a new tab.</a></p></div></div></div>
<!-- --><p>Now when the user request the page, the server again returns with the pre-generated HTML file. The user initially sees the skeleton UI since the data hasn&#x27;t been fetched yet.</p>
<!-- --><p>After parsing and rendering the initial content, the client fetches the data from the API route, and after getting a successful response, we can finally show the listings. <!-- --><em>(For simplicity, I&#x27;m not including the hydration call in this example)</em></p>
<!-- --><style>
                      .image-container {
                        width: 110%;
                        margin-bottom: 50px;
                      }

                      @media screen and (max-width: 767px) {
                        .image-container {
                          width: 95vw;
                        }
                      }

                    </style><div class="image-container"><span style="box-sizing:border-box;display:block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;padding-top:55.74468085106383%"></span><img alt="Flow chart" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%"><noscript><img alt="Flow chart" sizes="100vw" srcset="../_next/12-1.png 640w?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F12.png&amp;w=640&amp;q=75 640w, ../_next/12-2.png 750we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F12.png&amp;w=750&amp;q=75 750w, ../_next/12-3.png 828we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F12.png&amp;w=828&amp;q=75 828w, ../_next/12-4.png 1080we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F12.png&amp;w=1080&amp;q=75 1080w, ../_next/12-5.png 1200we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F12.png&amp;w=1200&amp;q=75 1200w, ../_next/12-6.png 1920we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F12.png&amp;w=1920&amp;q=75 1920w, ../_next/12-7.png 2048we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F12.png&amp;w=2048&amp;q=75 2048w, ../_next/12.png 3840we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F12.png&amp;w=3840&amp;q=75 3840w" src="../_next/12.png?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F12.png&amp;w=3840&amp;q=75" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%" loading="lazy"></noscript></span></div>
<!-- --><p>Although using <!-- --><strong style="color:#EDB658;background:-webkit-linear-gradient(45deg, #EDB658, #E7719B);-webkit-background-clip:text;-webkit-text-fill-color:transparent">Static Rendering with Client-Side</strong> <!-- --><span style="background-color:rgb(49 48 52 / 50%);padding:0.2rem 0.4rem;font-size:85%;margin:0.2rem;border-radius:0.2em;font-family:Menlo;font-weight:bolder"> <!-- -->fetch<!-- --></span> gives us a <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">good TTFB and FCP</strong>, the <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">LCP is not as good</strong> as it used to be, since we have to wait for the API route to return data in order to show the listings.<!-- --></p>
<!-- --><style>
                      .image-container {
                        width: 110%;
                        margin-bottom: 50px;
                      }

                      @media screen and (max-width: 767px) {
                        .image-container {
                          width: 95vw;
                        }
                      }

                    </style><div class="image-container"><span style="box-sizing:border-box;display:block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;padding-top:55.74468085106383%"></span><img alt="Flow chart" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%"><noscript><img alt="Flow chart" sizes="100vw" srcset="../_next/13-1.png 640w?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F13.png&amp;w=640&amp;q=75 640w, ../_next/13-2.png 750we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F13.png&amp;w=750&amp;q=75 750w, ../_next/13-3.png 828we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F13.png&amp;w=828&amp;q=75 828w, ../_next/13-4.png 1080we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F13.png&amp;w=1080&amp;q=75 1080w, ../_next/13-5.png 1200we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F13.png&amp;w=1200&amp;q=75 1200w, ../_next/13-6.png 1920we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F13.png&amp;w=1920&amp;q=75 1920w, ../_next/13-7.png 2048we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F13.png&amp;w=2048&amp;q=75 2048w, ../_next/13.png 3840we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F13.png&amp;w=3840&amp;q=75 3840w" src="../_next/13.png?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F13.png&amp;w=3840&amp;q=75" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%" loading="lazy"></noscript></span></div>
<!-- --><p>We might also <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">run into layout shifts</strong>, which can happen if our skeleton component doesn&#x27;t match with the content that eventually gets rendered after receiving the data.<!-- --></p>
<!-- --><p>Since we&#x27;re calling the API route on every page request, we can also run into <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">higher server costs</strong> as we pay for every execution.<!-- --></p>
<!-- --><p>When you use Next.js, you can actually choose between a few more static approaches that really improve the performance of your app when working with dynamic data.</p>
<!-- --><div class="styles_divider__vbkkn"></div>
<!-- --><style>
                      .image-container {
                        width: 110%;
                        margin-bottom: 50px;
                      }

                      @media screen and (max-width: 767px) {
                        .image-container {
                          width: 95vw;
                        }
                      }

                    </style><div class="image-container"><span style="box-sizing:border-box;display:block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;padding-top:55.74468085106383%"></span><img alt="Flow chart" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%"><noscript><img alt="Flow chart" sizes="100vw" srcset="../_next/14-1.png 640w?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F14.png&amp;w=640&amp;q=75 640w, ../_next/14-2.png 750we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F14.png&amp;w=750&amp;q=75 750w, ../_next/14-3.png 828we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F14.png&amp;w=828&amp;q=75 828w, ../_next/14-4.png 1080we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F14.png&amp;w=1080&amp;q=75 1080w, ../_next/14-5.png 1200we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F14.png&amp;w=1200&amp;q=75 1200w, ../_next/14-6.png 1920we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F14.png&amp;w=1920&amp;q=75 1920w, ../_next/14-7.png 2048we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F14.png&amp;w=2048&amp;q=75 2048w, ../_next/14.png 3840we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F14.png&amp;w=3840&amp;q=75 3840w" src="../_next/14.png?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F14.png&amp;w=3840&amp;q=75" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%" loading="lazy"></noscript></span></div>
<!-- --><p>The first approach, is using <!-- --><strong style="color:#EDB658;background:-webkit-linear-gradient(45deg, #EDB658, #E7719B);-webkit-background-clip:text;-webkit-text-fill-color:transparent">Static with</strong> <!-- --><span style="background-color:rgb(49 48 52 / 50%);padding:0.2rem 0.4rem;font-size:85%;margin:0.2rem;border-radius:0.2em;font-family:Menlo;font-weight:bolder"> <!-- -->getStaticProps<!-- --></span>. This method runs <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">server-side at build time</strong>, meaning that we can directly call our data provider within this method. If your data is available at build time, this can be a really good solution to add dynamic data to a static page.<!-- --></p>
<!-- --><style>
                      .image-container {
                        width: 110%;
                        margin-bottom: 50px;
                      }

                      @media screen and (max-width: 767px) {
                        .image-container {
                          width: 95vw;
                        }
                      }

                    </style><div class="image-container"><span style="box-sizing:border-box;display:block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;padding-top:55.74468085106383%"></span><img alt="Flow chart" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%"><noscript><img alt="Flow chart" sizes="100vw" srcset="../_next/15-1.png 640w?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F15.png&amp;w=640&amp;q=75 640w, ../_next/15-2.png 750we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F15.png&amp;w=750&amp;q=75 750w, ../_next/15-3.png 828we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F15.png&amp;w=828&amp;q=75 828w, ../_next/15-4.png 1080we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F15.png&amp;w=1080&amp;q=75 1080w, ../_next/15-5.png 1200we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F15.png&amp;w=1200&amp;q=75 1200w, ../_next/15-6.png 1920we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F15.png&amp;w=1920&amp;q=75 1920w, ../_next/15-7.png 2048we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F15.png&amp;w=2048&amp;q=75 2048w, ../_next/15.png 3840we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F15.png&amp;w=3840&amp;q=75 3840w" src="../_next/15.png?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F15.png&amp;w=3840&amp;q=75" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%" loading="lazy"></noscript></span></div>
<!-- --><p>Since the <!-- --><span style="background-color:rgb(49 48 52 / 50%);padding:0.2rem 0.4rem;font-size:85%;margin:0.2rem;border-radius:0.2em;font-family:Menlo;font-weight:bolder"> <!-- -->getStaticProps<!-- --></span> method runs server-side, we no longer have to deal with custom API Routes to fetch the data from, we can do this directly within the method.<!-- --></p>
<!-- --><p>We also no longer have to show a skeleton component, as there will never be a loading state; the <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">generated HTML already contains the fetched data</strong>.<!-- --></p>
<!-- --><div class="jsx-2cb62b8d759e2a53"><div class="lazyload-wrapper styles_lazyload-wrapper__iNCqt"><div class="video-placeholder"><p>Loading Video...</p><p id="sub"><a href="https://res.cloudinary.com/dq8xfyhu4/video/upload/v1609691928/CS%20Visualized//CS%20Visualized/Screen_Recording_2022-05-05_at_3.02.04_PM_avmzuy.jpg" target="_blank" rel="noreferrer">If it takes too long, you can click here to see the video in a new tab.</a></p></div></div></div>
<!-- --><p>When we build the project, the data provider gets called, and the returned data gets passed to the generated HTML.</p>
<!-- --><div class="jsx-2cb62b8d759e2a53"><div class="lazyload-wrapper styles_lazyload-wrapper__iNCqt"><div class="video-placeholder"><p>Loading Video...</p><p id="sub"><a href="https://res.cloudinary.com/dq8xfyhu4/video/upload/v1609691928/CS%20Visualized//CS%20Visualized/Screen_Recording_2022-05-05_at_3.06.26_PM_djvt57.jpg" target="_blank" rel="noreferrer">If it takes too long, you can click here to see the video in a new tab.</a></p></div></div></div>
<!-- --><p>Now when we request the page, we again fetch the HTML from the server. The response gets cached, rendered to the screen, and the browser again sends a request to fetch the JS bundles in order to hydrate the elements.</p>
<!-- --><style>
                      .image-container {
                        width: 110%;
                        margin-bottom: 50px;
                      }

                      @media screen and (max-width: 767px) {
                        .image-container {
                          width: 95vw;
                        }
                      }

                    </style><div class="image-container"><span style="box-sizing:border-box;display:block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;padding-top:55.74468085106383%"></span><img alt="Flow chart" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%"><noscript><img alt="Flow chart" sizes="100vw" srcset="../_next/16-1.png 640w?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F16.png&amp;w=640&amp;q=75 640w, ../_next/16-2.png 750we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F16.png&amp;w=750&amp;q=75 750w, ../_next/16-3.png 828we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F16.png&amp;w=828&amp;q=75 828w, ../_next/16-4.png 1080we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F16.png&amp;w=1080&amp;q=75 1080w, ../_next/16-5.png 1200we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F16.png&amp;w=1200&amp;q=75 1200w, ../_next/16-6.png 1920we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F16.png&amp;w=1920&amp;q=75 1920w, ../_next/16-7.png 2048we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F16.png&amp;w=2048&amp;q=75 2048w, ../_next/16.png 3840we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F16.png&amp;w=3840&amp;q=75 3840w" src="../_next/16.png?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F16.png&amp;w=3840&amp;q=75" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%" loading="lazy"></noscript></span></div>
<!-- --><p>The network and main thread work are identical to what we saw before when we just statically rendered the content without injecting any data at build time, so from a user perspective, we again get a <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">great performance</strong>.<!-- --></p>
<!-- --><style>
                      .image-container {
                        width: 110%;
                        margin-bottom: 50px;
                      }

                      @media screen and (max-width: 767px) {
                        .image-container {
                          width: 95vw;
                        }
                      }

                    </style><div class="image-container"><span style="box-sizing:border-box;display:block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;padding-top:55.74468085106383%"></span><img alt="Flow chart" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%"><noscript><img alt="Flow chart" sizes="100vw" srcset="../_next/17-1.png 640w?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F17.png&amp;w=640&amp;q=75 640w, ../_next/17-2.png 750we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F17.png&amp;w=750&amp;q=75 750w, ../_next/17-3.png 828we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F17.png&amp;w=828&amp;q=75 828w, ../_next/17-4.png 1080we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F17.png&amp;w=1080&amp;q=75 1080w, ../_next/17-5.png 1200we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F17.png&amp;w=1200&amp;q=75 1200w, ../_next/17-6.png 1920we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F17.png&amp;w=1920&amp;q=75 1920w, ../_next/17-7.png 2048we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F17.png&amp;w=2048&amp;q=75 2048w, ../_next/17.png 3840we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F17.png&amp;w=3840&amp;q=75 3840w" src="../_next/17.png?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F17.png&amp;w=3840&amp;q=75" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%" loading="lazy"></noscript></span></div>
<!-- --><p>However, as a developer, you can quickly run into some issues.</p>
<!-- --><p>Imagine if we statically built hundreds of pages, which can easily happen on a blog or ecommerce website, and we’re calling the <!-- --><span style="background-color:rgb(49 48 52 / 50%);padding:0.2rem 0.4rem;font-size:85%;margin:0.2rem;border-radius:0.2em;font-family:Menlo;font-weight:bolder"> <!-- -->getStaticProps<!-- --></span> method for all these pages.  This can result in <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">really long build times</strong>, and if you’re using an external API, you can even <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">hit the request limit</strong> pretty fast, or get charged a lot of money if they charge per request.<!-- --></p>
<!-- --><p>Another issue is that we’re <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">only renewing the data at build time</strong>, meaning we’d have to redeploy the website to update the content.<!-- --></p>
<!-- --><div class="styles_divider__vbkkn"></div>
<!-- --><style>
                      .image-container {
                        width: 110%;
                        margin-bottom: 50px;
                      }

                      @media screen and (max-width: 767px) {
                        .image-container {
                          width: 95vw;
                        }
                      }

                    </style><div class="image-container"><span style="box-sizing:border-box;display:block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;padding-top:55.74468085106383%"></span><img alt="Flow chart" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%"><noscript><img alt="Flow chart" sizes="100vw" srcset="../_next/18-1.png 640w?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F18.png&amp;w=640&amp;q=75 640w, ../_next/18-2.png 750we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F18.png&amp;w=750&amp;q=75 750w, ../_next/18-3.png 828we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F18.png&amp;w=828&amp;q=75 828w, ../_next/18-4.png 1080we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F18.png&amp;w=1080&amp;q=75 1080w, ../_next/18-5.png 1200we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F18.png&amp;w=1200&amp;q=75 1200w, ../_next/18-6.png 1920we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F18.png&amp;w=1920&amp;q=75 1920w, ../_next/18-7.png 2048we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F18.png&amp;w=2048&amp;q=75 2048w, ../_next/18.png 3840we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F18.png&amp;w=3840&amp;q=75 3840w" src="../_next/18.png?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F18.png&amp;w=3840&amp;q=75" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%" loading="lazy"></noscript></span></div>
<!-- --><p>Luckily, we can use <!-- --><strong style="color:#EDB658;background:-webkit-linear-gradient(45deg, #EDB658, #E7719B);-webkit-background-clip:text;-webkit-text-fill-color:transparent">Incremental Static Regeneration</strong> to solve our build time and dynamic data issues.<!-- --></p>
<!-- --><p>With ISR, we can decide to <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">only pre-render certain pages</strong>, and render the other pages on-demand when the user requests them, resulting in much shorter build times. It also allows us to <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">automatically invalidate the cache and regenerate the page</strong> after a certain interval.<!-- --></p>
<!-- --><style>
                      .image-container {
                        width: 110%;
                        margin-bottom: 50px;
                      }

                      @media screen and (max-width: 767px) {
                        .image-container {
                          width: 95vw;
                        }
                      }

                    </style><div class="image-container"><span style="box-sizing:border-box;display:block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;padding-top:55.74468085106383%"></span><img alt="Flow chart" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%"><noscript><img alt="Flow chart" sizes="100vw" srcset="../_next/19-1.png 640w?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F19.png&amp;w=640&amp;q=75 640w, ../_next/19-2.png 750we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F19.png&amp;w=750&amp;q=75 750w, ../_next/19-3.png 828we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F19.png&amp;w=828&amp;q=75 828w, ../_next/19-4.png 1080we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F19.png&amp;w=1080&amp;q=75 1080w, ../_next/19-5.png 1200we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F19.png&amp;w=1200&amp;q=75 1200w, ../_next/19-6.png 1920we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F19.png&amp;w=1920&amp;q=75 1920w, ../_next/19-7.png 2048we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F19.png&amp;w=2048&amp;q=75 2048w, ../_next/19.png 3840we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F19.png&amp;w=3840&amp;q=75 3840w" src="../_next/19.png?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F19.png&amp;w=3840&amp;q=75" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%" loading="lazy"></noscript></span></div>
<!-- --><p>Imagine if we wanted to be able to show individual listings as well, and pre-render these pages to get great performance when a user clicks on a listing.</p>
<!-- --><style>
                      .image-container {
                        width: 110%;
                        margin-bottom: 50px;
                      }

                      @media screen and (max-width: 767px) {
                        .image-container {
                          width: 95vw;
                        }
                      }

                    </style><div class="image-container"><span style="box-sizing:border-box;display:block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;padding-top:55.74468085106383%"></span><img alt="Flow chart" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%"><noscript><img alt="Flow chart" sizes="100vw" srcset="../_next/20-1.png 640w?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F20.png&amp;w=640&amp;q=75 640w, ../_next/20-2.png 750we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F20.png&amp;w=750&amp;q=75 750w, ../_next/20-3.png 828we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F20.png&amp;w=828&amp;q=75 828w, ../_next/20-4.png 1080we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F20.png&amp;w=1080&amp;q=75 1080w, ../_next/20-5.png 1200we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F20.png&amp;w=1200&amp;q=75 1200w, ../_next/20-6.png 1920we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F20.png&amp;w=1920&amp;q=75 1920w, ../_next/20-7.png 2048we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F20.png&amp;w=2048&amp;q=75 2048w, ../_next/20.png 3840we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F20.png&amp;w=3840&amp;q=75 3840w" src="../_next/20.png?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F20.png&amp;w=3840&amp;q=75" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%" loading="lazy"></noscript></span></div>
<!-- --><p>Using Next.js, we can have dynamic paths with the combination of <!-- --><span style="background-color:rgb(49 48 52 / 50%);padding:0.2rem 0.4rem;font-size:85%;margin:0.2rem;border-radius:0.2em;font-family:Menlo;font-weight:bolder"> <!-- -->getStaticPaths<!-- --></span> to tell Next.js which pages to pre-generate, based on their query parameter.<!-- --></p>
<!-- --><p>In this case, we&#x27;re fetching all listings and pre-generating the pages for each and every one of them. If we had thousands of listings, this would take a really long time to finish.</p>
<!-- --><style>
                      .image-container {
                        width: 110%;
                        margin-bottom: 50px;
                      }

                      @media screen and (max-width: 767px) {
                        .image-container {
                          width: 95vw;
                        }
                      }

                    </style><div class="image-container"><span style="box-sizing:border-box;display:block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;padding-top:55.74468085106383%"></span><img alt="Flow chart" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%"><noscript><img alt="Flow chart" sizes="100vw" srcset="../_next/21-1.png 640w?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F21.png&amp;w=640&amp;q=75 640w, ../_next/21-2.png 750we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F21.png&amp;w=750&amp;q=75 750w, ../_next/21-3.png 828we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F21.png&amp;w=828&amp;q=75 828w, ../_next/21-4.png 1080we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F21.png&amp;w=1080&amp;q=75 1080w, ../_next/21-5.png 1200we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F21.png&amp;w=1200&amp;q=75 1200w, ../_next/21-6.png 1920we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F21.png&amp;w=1920&amp;q=75 1920w, ../_next/21-7.png 2048we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F21.png&amp;w=2048&amp;q=75 2048w, ../_next/21.png 3840we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F21.png&amp;w=3840&amp;q=75 3840w" src="../_next/21.png?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F21.png&amp;w=3840&amp;q=75" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%" loading="lazy"></noscript></span></div>
<!-- --><p>Instead, we can tell Next to only pre-generate a subset of all the pages, and render a fallback while the listing is page generated on-demand.</p>
<!-- --><div class="jsx-2cb62b8d759e2a53"><div class="lazyload-wrapper styles_lazyload-wrapper__iNCqt"><div class="video-placeholder"><p>Loading Video...</p><p id="sub"><a href="https://res.cloudinary.com/dq8xfyhu4/video/upload/v1609691928/CS%20Visualized//CS%20Visualized/Screen_Recording_2022-05-05_at_3.49.59_PM_deygni.jpg" target="_blank" rel="noreferrer">If it takes too long, you can click here to see the video in a new tab.</a></p></div></div></div>
<!-- --><p>The pre-rendered pages behave the exact same. If a user requests a page that hasn&#x27;t been generated yet, it gets generated on-demand, after which it <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">automatically gets cached by the edge</strong>. That means that only the first user might have a worse experience as the page still needs to be generated, but everyone else can benefit from getting a fast, cached response.<!-- --></p>
<!-- --><p>Our long build times have been solved, but we still don’t want to have to redeploy the landing page every time to renew the data with the latest listings.</p>
<!-- --><style>
                      .image-container {
                        width: 110%;
                        margin-bottom: 50px;
                      }

                      @media screen and (max-width: 767px) {
                        .image-container {
                          width: 95vw;
                        }
                      }

                    </style><div class="image-container"><span style="box-sizing:border-box;display:block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;padding-top:55.74468085106383%"></span><img alt="Flow chart" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%"><noscript><img alt="Flow chart" sizes="100vw" srcset="../_next/22-1.png 640w?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F22.png&amp;w=640&amp;q=75 640w, ../_next/22-2.png 750we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F22.png&amp;w=750&amp;q=75 750w, ../_next/22-3.png 828we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F22.png&amp;w=828&amp;q=75 828w, ../_next/22-4.png 1080we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F22.png&amp;w=1080&amp;q=75 1080w, ../_next/22-5.png 1200we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F22.png&amp;w=1200&amp;q=75 1200w, ../_next/22-6.png 1920we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F22.png&amp;w=1920&amp;q=75 1920w, ../_next/22-7.png 2048we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F22.png&amp;w=2048&amp;q=75 2048w, ../_next/22.png 3840we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F22.png&amp;w=3840&amp;q=75 3840w" src="../_next/22.png?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F22.png&amp;w=3840&amp;q=75" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%" loading="lazy"></noscript></span></div>
<!-- --><p>Instead of only renewing the data at build time, we can automatically invalidate the cache and regenerate the page in the background on a certain interval. We can use this by <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">adding a</strong> <!-- --><span style="background-color:rgb(49 48 52 / 50%);padding:0.2rem 0.4rem;font-size:85%;margin:0.2rem;border-radius:0.2em;font-family:Menlo;font-weight:bolder"> <!-- -->revalidate<!-- --></span> <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">field</strong> to the returned object.<!-- --></p>
<!-- --><div class="jsx-2cb62b8d759e2a53"><div class="lazyload-wrapper styles_lazyload-wrapper__iNCqt"><div class="video-placeholder"><p>Loading Video...</p><p id="sub"><a href="https://res.cloudinary.com/dq8xfyhu4/video/upload/v1609691928/CS%20Visualized//CS%20Visualized/updated_jvhqnv.jpg" target="_blank" rel="noreferrer">If it takes too long, you can click here to see the video in a new tab.</a></p></div></div></div>
<!-- --><p>Now when a user requests a stale page, meaning a page that has been cached for longer than the specified number of seconds, the user gets to see a stale page at first. In the background, a <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">page regeneration is triggered</strong> while the user gets to see the stale page.  Once the page has been regenerated in the background, the <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">cache gets invalidated and updated with the latest page</strong>.<!-- --></p>
<!-- --><div class="jsx-2cb62b8d759e2a53"><div class="lazyload-wrapper styles_lazyload-wrapper__iNCqt"><div class="video-placeholder"><p>Loading Video...</p><p id="sub"><a href="https://res.cloudinary.com/dq8xfyhu4/video/upload/v1609691928/CS%20Visualized//CS%20Visualized/Screen_Recording_2022-05-05_at_4.59.00_PM_ukri1c.jpg" target="_blank" rel="noreferrer">If it takes too long, you can click here to see the video in a new tab.</a></p></div></div></div>
<!-- --><p>When the user requests the page again, for example by refreshing it, they’ll see the updated content.</p>
<!-- --><style>
                      .image-container {
                        width: 110%;
                        margin-bottom: 50px;
                      }

                      @media screen and (max-width: 767px) {
                        .image-container {
                          width: 95vw;
                        }
                      }

                    </style><div class="image-container"><span style="box-sizing:border-box;display:block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;padding-top:55.74468085106383%"></span><img alt="Flow chart" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%"><noscript><img alt="Flow chart" sizes="100vw" srcset="../_next/23-1.png 640w?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F23.png&amp;w=640&amp;q=75 640w, ../_next/23-2.png 750we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F23.png&amp;w=750&amp;q=75 750w, ../_next/23-3.png 828we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F23.png&amp;w=828&amp;q=75 828w, ../_next/23-4.png 1080we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F23.png&amp;w=1080&amp;q=75 1080w, ../_next/23-5.png 1200we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F23.png&amp;w=1200&amp;q=75 1200w, ../_next/23-6.png 1920we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F23.png&amp;w=1920&amp;q=75 1920w, ../_next/23-7.png 2048we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F23.png&amp;w=2048&amp;q=75 2048w, ../_next/23.png 3840we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F23.png&amp;w=3840&amp;q=75 3840w" src="../_next/23.png?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F23.png&amp;w=3840&amp;q=75" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%" loading="lazy"></noscript></span></div>
<!-- --><p>With <!-- --><strong style="color:#EDB658;background:-webkit-linear-gradient(45deg, #EDB658, #E7719B);-webkit-background-clip:text;-webkit-text-fill-color:transparent">Incremental Static Regeneration</strong>, we can show dynamic content by automatically revalidating the page every number of seconds.<!-- --></p>
<!-- --><p>Although this is already a huge improvement to what we had before, we can run into some issues here. It&#x27;s likely that our content doesn’t update every number of seconds, which would mean that we’re <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">unnecessarily regenerating the page and invalidating the cache</strong> every number of seconds. Every time, we&#x27;re invoking our serverless functions, which could result in <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">higher server costs</strong>.<!-- --></p>
<!-- --><div class="styles_divider__vbkkn"></div>
<!-- --><style>
                      .image-container {
                        width: 110%;
                        margin-bottom: 50px;
                      }

                      @media screen and (max-width: 767px) {
                        .image-container {
                          width: 95vw;
                        }
                      }

                    </style><div class="image-container"><span style="box-sizing:border-box;display:block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;padding-top:55.74468085106383%"></span><img alt="Flow chart" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%"><noscript><img alt="Flow chart" sizes="100vw" srcset="../_next/24-1.png 640w?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F24.png&amp;w=640&amp;q=75 640w, ../_next/24-2.png 750we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F24.png&amp;w=750&amp;q=75 750w, ../_next/24-3.png 828we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F24.png&amp;w=828&amp;q=75 828w, ../_next/24-4.png 1080we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F24.png&amp;w=1080&amp;q=75 1080w, ../_next/24-5.png 1200we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F24.png&amp;w=1200&amp;q=75 1200w, ../_next/24-6.png 1920we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F24.png&amp;w=1920&amp;q=75 1920w, ../_next/24-7.png 2048we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F24.png&amp;w=2048&amp;q=75 2048w, ../_next/24.png 3840we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F24.png&amp;w=3840&amp;q=75 3840w" src="../_next/24.png?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F24.png&amp;w=3840&amp;q=75" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%" loading="lazy"></noscript></span></div>
<!-- --><p>The best option here, is to use <!-- --><strong style="color:#EDB658;background:-webkit-linear-gradient(45deg, #EDB658, #E7719B);-webkit-background-clip:text;-webkit-text-fill-color:transparent">On-demand Incremental Static Regeneration</strong>.<!-- --></p>
<!-- --><p><strong style="color:#EDB658;background:-webkit-linear-gradient(45deg, #EDB658, #E7719B);-webkit-background-clip:text;-webkit-text-fill-color:transparent">On-demand ISR</strong> allows us to use <!-- --><strong style="color:#EDB658;background:-webkit-linear-gradient(45deg, #EDB658, #E7719B);-webkit-background-clip:text;-webkit-text-fill-color:transparent">ISR</strong>, but instead of regenerating on a certain interval, we can <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">base the regeneration on certain events</strong>.<!-- --></p>
<!-- --><style>
                      .image-container {
                        width: 110%;
                        margin-bottom: 50px;
                      }

                      @media screen and (max-width: 767px) {
                        .image-container {
                          width: 95vw;
                        }
                      }

                    </style><div class="image-container"><span style="box-sizing:border-box;display:block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;padding-top:55.74468085106383%"></span><img alt="Flow chart" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%"><noscript><img alt="Flow chart" sizes="100vw" srcset="../_next/25-1.png 640w?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F25.png&amp;w=640&amp;q=75 640w, ../_next/25-2.png 750we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F25.png&amp;w=750&amp;q=75 750w, ../_next/25-3.png 828we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F25.png&amp;w=828&amp;q=75 828w, ../_next/25-4.png 1080we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F25.png&amp;w=1080&amp;q=75 1080w, ../_next/25-5.png 1200we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F25.png&amp;w=1200&amp;q=75 1200w, ../_next/25-6.png 1920we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F25.png&amp;w=1920&amp;q=75 1920w, ../_next/25-7.png 2048we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F25.png&amp;w=2048&amp;q=75 2048w, ../_next/25.png 3840we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F25.png&amp;w=3840&amp;q=75 3840w" src="../_next/25.png?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F25.png&amp;w=3840&amp;q=75" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%" loading="lazy"></noscript></span></div>
<!-- --><p>Instead of relying on the <!-- --><span style="background-color:rgb(49 48 52 / 50%);padding:0.2rem 0.4rem;font-size:85%;margin:0.2rem;border-radius:0.2em;font-family:Menlo;font-weight:bolder"> <!-- -->revalidate<!-- --></span> field, we can manually <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">revalidate pages in API routes based on incoming requests</strong>.<!-- --></p>
<!-- --><div class="jsx-2cb62b8d759e2a53"><div class="lazyload-wrapper styles_lazyload-wrapper__iNCqt"><div class="video-placeholder"><p>Loading Video...</p><p id="sub"><a href="https://res.cloudinary.com/dq8xfyhu4/video/upload/v1609691928/CS%20Visualized//CS%20Visualized/Screen_Recording_2022-05-05_at_5.24.13_PM_xeumhu.jpg" target="_blank" rel="noreferrer">If it takes too long, you can click here to see the video in a new tab.</a></p></div></div></div>
<!-- --><p>For example, we can listen to an incoming webhook event that tells us when new data has been added to our data provider. When we invoke the revalidate method, the page on the specified path <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">automatically gets regenerated</strong>.<!-- --></p>
<!-- --><p>Another huge benefit of using <!-- --><strong style="color:#EDB658;background:-webkit-linear-gradient(45deg, #EDB658, #E7719B);-webkit-background-clip:text;-webkit-text-fill-color:transparent">on-demand ISR</strong> over <!-- --><strong style="color:#EDB658;background:-webkit-linear-gradient(45deg, #EDB658, #E7719B);-webkit-background-clip:text;-webkit-text-fill-color:transparent">regular ISR</strong>, is the fact that the newly generated page gets <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">distributed throughout the entire edge network</strong>! With <!-- --><strong style="color:#EDB658;background:-webkit-linear-gradient(45deg, #EDB658, #E7719B);-webkit-background-clip:text;-webkit-text-fill-color:transparent">regular ISR</strong>, the returned response only gets cached in the regions where users sent requests from.<!-- --></p>
<!-- --><p>However, with <!-- --><strong style="color:#EDB658;background:-webkit-linear-gradient(45deg, #EDB658, #E7719B);-webkit-background-clip:text;-webkit-text-fill-color:transparent">on-demand ISR</strong>, users from all over the world will <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">automatically hit the edge cache, without ever seeing stale content</strong>.  We also don’t have to worry about unnecessarily invoking a serverless function every number of seconds if content hasn’t been updated, making it a much cheaper pattern to use.<!-- --></p>
<!-- --><style>
                      .image-container {
                        width: 110%;
                        margin-bottom: 50px;
                      }

                      @media screen and (max-width: 767px) {
                        .image-container {
                          width: 95vw;
                        }
                      }

                    </style><div class="image-container"><span style="box-sizing:border-box;display:block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;padding-top:55.74468085106383%"></span><img alt="Flow chart" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%"><noscript><img alt="Flow chart" sizes="100vw" srcset="../_next/26-1.png 640w?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F26.png&amp;w=640&amp;q=75 640w, ../_next/26-2.png 750we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F26.png&amp;w=750&amp;q=75 750w, ../_next/26-3.png 828we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F26.png&amp;w=828&amp;q=75 828w, ../_next/26-4.png 1080we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F26.png&amp;w=1080&amp;q=75 1080w, ../_next/26-5.png 1200we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F26.png&amp;w=1200&amp;q=75 1200w, ../_next/26-6.png 1920we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F26.png&amp;w=1920&amp;q=75 1920w, ../_next/26-7.png 2048we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F26.png&amp;w=2048&amp;q=75 2048w, ../_next/26.png 3840we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F26.png&amp;w=3840&amp;q=75 3840w" src="../_next/26.png?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F26.png&amp;w=3840&amp;q=75" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%" loading="lazy"></noscript></span></div>
<!-- --><p><strong style="color:#EDB658;background:-webkit-linear-gradient(45deg, #EDB658, #E7719B);-webkit-background-clip:text;-webkit-text-fill-color:transparent">On-demand ISR</strong> gives us all the <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">performance benefits</strong>, combined with a <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">great developer experience</strong>. We don&#x27;t have to worry about high server costs as long as we don&#x27;t trigger a revalidation too often, and we can bring a great performance to users all over the world in combination with the edge cache.<!-- --></p>
<!-- --><div class="styles_divider__vbkkn"></div>
<!-- --><style>
                      .image-container {
                        width: 110%;
                        margin-bottom: 50px;
                      }

                      @media screen and (max-width: 767px) {
                        .image-container {
                          width: 95vw;
                        }
                      }

                    </style><div class="image-container"><span style="box-sizing:border-box;display:block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;padding-top:55.74468085106383%"></span><img alt="Flow chart" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%"><noscript><img alt="Flow chart" sizes="100vw" srcset="../_next/27-1.png 640w?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F27.png&amp;w=640&amp;q=75 640w, ../_next/27-2.png 750we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F27.png&amp;w=750&amp;q=75 750w, ../_next/27-3.png 828we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F27.png&amp;w=828&amp;q=75 828w, ../_next/27-4.png 1080we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F27.png&amp;w=1080&amp;q=75 1080w, ../_next/27-5.png 1200we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F27.png&amp;w=1200&amp;q=75 1200w, ../_next/27-6.png 1920we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F27.png&amp;w=1920&amp;q=75 1920w, ../_next/27-7.png 2048we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F27.png&amp;w=2048&amp;q=75 2048w, ../_next/27.png 3840we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F27.png&amp;w=3840&amp;q=75 3840w" src="../_next/27.png?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F27.png&amp;w=3840&amp;q=75" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%" loading="lazy"></noscript></span></div>
<!-- --><p><strong style="color:#EDB658;background:-webkit-linear-gradient(45deg, #EDB658, #E7719B);-webkit-background-clip:text;-webkit-text-fill-color:transparent">Static generation</strong> is an amazing pattern that can be used for tons of use cases, especially in combination with <!-- --><strong style="color:#EDB658;background:-webkit-linear-gradient(45deg, #EDB658, #E7719B);-webkit-background-clip:text;-webkit-text-fill-color:transparent">ISR</strong>.<!-- --></p>
<!-- --><p>We can have an incredibly fast and dynamic website, that&#x27;s also <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">always online</strong>, since there’s always a cached version available, and we end up with lower costs.<!-- --></p>
<!-- --><div class="styles_divider__vbkkn"></div>
<!-- --><p>However, there are also tons of use cases where static isn’t the best way to go, for example for <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">highly dynamic, personalized pages</strong> that are <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">different for every user</strong>.<!-- --></p>
<!-- --><div class="styles_divider__vbkkn"></div>
<!-- --><style>
                      .image-container {
                        width: 110%;
                        margin-bottom: 50px;
                      }

                      @media screen and (max-width: 767px) {
                        .image-container {
                          width: 95vw;
                        }
                      }

                    </style><div class="image-container"><span style="box-sizing:border-box;display:block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;padding-top:55.74468085106383%"></span><img alt="Flow chart" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%"><noscript><img alt="Flow chart" sizes="100vw" srcset="../_next/28-1.png 640w?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F28.png&amp;w=640&amp;q=75 640w, ../_next/28-2.png 750we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F28.png&amp;w=750&amp;q=75 750w, ../_next/28-3.png 828we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F28.png&amp;w=828&amp;q=75 828w, ../_next/28-4.png 1080we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F28.png&amp;w=1080&amp;q=75 1080w, ../_next/28-5.png 1200we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F28.png&amp;w=1200&amp;q=75 1200w, ../_next/28-6.png 1920we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F28.png&amp;w=1920&amp;q=75 1920w, ../_next/28-7.png 2048we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F28.png&amp;w=2048&amp;q=75 2048w, ../_next/28.png 3840we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F28.png&amp;w=3840&amp;q=75 3840w" src="../_next/28.png?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F28.png&amp;w=3840&amp;q=75" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%" loading="lazy"></noscript></span></div>
<!-- --><p>In that case, we might want to use <!-- --><strong style="color:#EDB658;background:-webkit-linear-gradient(45deg, #EDB658, #E7719B);-webkit-background-clip:text;-webkit-text-fill-color:transparent">Server-Side Rendering</strong>. Whereas we generated the HTML at build time using static generation, with server-side rendering, we <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">generate the HTML on every request</strong>.<!-- --></p>
<!-- --><p>This can be a great approach for pages that contain highly personalized data, for example data based on the user cookie, or just generally any <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">data that&#x27;s contained within the user&#x27;s request</strong>. It&#x27;s also good for pages that should be <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">render-blocking</strong>, perhaps based on authentication state.<!-- --></p>
<!-- --><style>
                      .image-container {
                        width: 110%;
                        margin-bottom: 50px;
                      }

                      @media screen and (max-width: 767px) {
                        .image-container {
                          width: 95vw;
                        }
                      }

                    </style><div class="image-container"><span style="box-sizing:border-box;display:block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;padding-top:55.74468085106383%"></span><img alt="Flow chart" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%"><noscript><img alt="Flow chart" sizes="100vw" srcset="../_next/29-1.png 640w?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F29.png&amp;w=640&amp;q=75 640w, ../_next/29-2.png 750we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F29.png&amp;w=750&amp;q=75 750w, ../_next/29-3.png 828we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F29.png&amp;w=828&amp;q=75 828w, ../_next/29-4.png 1080we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F29.png&amp;w=1080&amp;q=75 1080w, ../_next/29-5.png 1200we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F29.png&amp;w=1200&amp;q=75 1200w, ../_next/29-6.png 1920we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F29.png&amp;w=1920&amp;q=75 1920w, ../_next/29-7.png 2048we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F29.png&amp;w=2048&amp;q=75 2048w, ../_next/29.png 3840we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F29.png&amp;w=3840&amp;q=75 3840w" src="../_next/29.png?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F29.png&amp;w=3840&amp;q=75" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%" loading="lazy"></noscript></span></div>
<!-- --><p>An example of a highly dynamic page is anything that requires a user cookie, is a dashboard. This dashboard is only shown when a user is authenticated, and shows mainly user-specific data.</p>
<!-- --><style>
                      .image-container {
                        width: 110%;
                        margin-bottom: 50px;
                      }

                      @media screen and (max-width: 767px) {
                        .image-container {
                          width: 95vw;
                        }
                      }

                    </style><div class="image-container"><span style="box-sizing:border-box;display:block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;padding-top:55.74468085106383%"></span><img alt="Flow chart" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%"><noscript><img alt="Flow chart" sizes="100vw" srcset="../_next/30-1.png 640w?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F30.png&amp;w=640&amp;q=75 640w, ../_next/30-2.png 750we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F30.png&amp;w=750&amp;q=75 750w, ../_next/30-3.png 828we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F30.png&amp;w=828&amp;q=75 828w, ../_next/30-4.png 1080we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F30.png&amp;w=1080&amp;q=75 1080w, ../_next/30-5.png 1200we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F30.png&amp;w=1200&amp;q=75 1200w, ../_next/30-6.png 1920we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F30.png&amp;w=1920&amp;q=75 1920w, ../_next/30-7.png 2048we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F30.png&amp;w=2048&amp;q=75 2048w, ../_next/30.png 3840we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F30.png&amp;w=3840&amp;q=75 3840w" src="../_next/30.png?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F30.png&amp;w=3840&amp;q=75" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%" loading="lazy"></noscript></span></div>
<!-- --><p>With Next.js, we can <!-- --><strong style="color:#EDB658;background:-webkit-linear-gradient(45deg, #EDB658, #E7719B);-webkit-background-clip:text;-webkit-text-fill-color:transparent">server-render a page using the <!-- --><span style="background-color:rgb(49 48 52 / 50%);padding:0.2rem 0.4rem;font-size:85%;margin:0.2rem;border-radius:0.2em;font-family:Menlo;font-weight:bolder"> <!-- -->getServerSideProps<!-- --></span> method<!-- --></strong>. This method runs server-side on every request, and eventually passes the returned data to the page in order to generate the HTML.<!-- --></p>
<!-- --><div class="jsx-2cb62b8d759e2a53"><div class="lazyload-wrapper styles_lazyload-wrapper__iNCqt"><div class="video-placeholder"><p>Loading Video...</p><p id="sub"><a href="https://res.cloudinary.com/dq8xfyhu4/video/upload/v1609691928/CS%20Visualized//CS%20Visualized/Screen_Recording_2022-05-05_at_5.31.41_PM_oxsq12.jpg" target="_blank" rel="noreferrer">If it takes too long, you can click here to see the video in a new tab.</a></p></div></div></div>
<!-- --><p>When a user requests the page, the <!-- --><span style="background-color:rgb(49 48 52 / 50%);padding:0.2rem 0.4rem;font-size:85%;margin:0.2rem;border-radius:0.2em;font-family:Menlo;font-weight:bolder"> <!-- -->getServerSideProps<!-- --></span> method runs, after which the page gets generated, and sent to the client. The client can quickly render this HTML, and can send an another request to fetch the JavaScript bundle to hydrate the elements.<!-- --></p>
<!-- --><p>The generated pages are unique to every request, meaning they <!-- --><strong style="color:#EDB658;background:-webkit-linear-gradient(45deg, #EDB658, #E7719B);-webkit-background-clip:text;-webkit-text-fill-color:transparent">aren’t automatically cached by our CDN</strong>.  Although this is the expected behavior,  there’s more to take into consideration if you want to get a good performance.<!-- --></p>
<!-- --><style>
                      .image-container {
                        width: 110%;
                        margin-bottom: 50px;
                      }

                      @media screen and (max-width: 767px) {
                        .image-container {
                          width: 95vw;
                        }
                      }

                    </style><div class="image-container"><span style="box-sizing:border-box;display:block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;padding-top:55.74468085106383%"></span><img alt="Flow chart" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%"><noscript><img alt="Flow chart" sizes="100vw" srcset="../_next/31-1.png 640w?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F31.png&amp;w=640&amp;q=75 640w, ../_next/31-2.png 750we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F31.png&amp;w=750&amp;q=75 750w, ../_next/31-3.png 828we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F31.png&amp;w=828&amp;q=75 828w, ../_next/31-4.png 1080we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F31.png&amp;w=1080&amp;q=75 1080w, ../_next/31-5.png 1200we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F31.png&amp;w=1200&amp;q=75 1200w, ../_next/31-6.png 1920we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F31.png&amp;w=1920&amp;q=75 1920w, ../_next/31-7.png 2048we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F31.png&amp;w=2048&amp;q=75 2048w, ../_next/31.png 3840we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F31.png&amp;w=3840&amp;q=75 3840w" src="../_next/31.png?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F31.png&amp;w=3840&amp;q=75" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%" loading="lazy"></noscript></span></div>
<!-- --><p>When we look at the network and main thread, it looks pretty similar to what we initially saw with static rendering. The FCP is basically equal to the LCP, and we can easily avoid layout shift, as we&#x27;re not dynamically rendering content.</p>
<!-- --><div class="jsx-2cb62b8d759e2a53"><div class="lazyload-wrapper styles_lazyload-wrapper__iNCqt"><div class="video-placeholder"><p>Loading Video...</p><p id="sub"><a href="https://res.cloudinary.com/dq8xfyhu4/video/upload/v1609691928/CS%20Visualized//CS%20Visualized/Screen_Recording_2022-05-05_at_5.36.49_PM_kkuxv3.jpg" target="_blank" rel="noreferrer">If it takes too long, you can click here to see the video in a new tab.</a></p></div></div></div>
<!-- --><p>However, when we compare static rendering an server rendering, you can see that the TTFB can be very short when we statically render data since it&#x27;s already pre-generated. If a page is server-rendered however, the <!-- --><strong style="color:#EDB658;background:-webkit-linear-gradient(45deg, #EDB658, #E7719B);-webkit-background-clip:text;-webkit-text-fill-color:transparent">TTFB can be a lot longer</strong>, as it still needs to be generated.<!-- --></p>
<!-- --><style>
                      .image-container {
                        width: 110%;
                        margin-bottom: 50px;
                      }

                      @media screen and (max-width: 767px) {
                        .image-container {
                          width: 95vw;
                        }
                      }

                    </style><div class="image-container"><span style="box-sizing:border-box;display:block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;padding-top:55.74468085106383%"></span><img alt="Flow chart" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%"><noscript><img alt="Flow chart" sizes="100vw" srcset="../_next/32-1.png 640w?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F32.png&amp;w=640&amp;q=75 640w, ../_next/32-2.png 750we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F32.png&amp;w=750&amp;q=75 750w, ../_next/32-3.png 828we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F32.png&amp;w=828&amp;q=75 828w, ../_next/32-4.png 1080we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F32.png&amp;w=1080&amp;q=75 1080w, ../_next/32-5.png 1200we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F32.png&amp;w=1200&amp;q=75 1200w, ../_next/32-6.png 1920we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F32.png&amp;w=1920&amp;q=75 1920w, ../_next/32-7.png 2048we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F32.png&amp;w=2048&amp;q=75 2048w, ../_next/32.png 3840we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F32.png&amp;w=3840&amp;q=75 3840w" src="../_next/32.png?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F32.png&amp;w=3840&amp;q=75" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%" loading="lazy"></noscript></span></div>
<!-- --><p>Although server-rendering is a great method when you want to render highly personalized data, there are some things to take into consideration to achieve a great user experience.</p>
<!-- --><p>We might also run into way higher server costs, which in some cases is completely worth it, but there are a few things you can do as a user to optimize your SSR performance!</p>
<!-- --><div class="styles_divider__vbkkn"></div>
<!-- --><style>
                      .image-container {
                        width: 110%;
                        margin-bottom: 50px;
                      }

                      @media screen and (max-width: 767px) {
                        .image-container {
                          width: 95vw;
                        }
                      }

                    </style><div class="image-container"><span style="box-sizing:border-box;display:block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;padding-top:55.74468085106383%"></span><img alt="Flow chart" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%"><noscript><img alt="Flow chart" sizes="100vw" srcset="../_next/33-1.png 640w?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F33.png&amp;w=640&amp;q=75 640w, ../_next/33-2.png 750we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F33.png&amp;w=750&amp;q=75 750w, ../_next/33-3.png 828we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F33.png&amp;w=828&amp;q=75 828w, ../_next/33-4.png 1080we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F33.png&amp;w=1080&amp;q=75 1080w, ../_next/33-5.png 1200we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F33.png&amp;w=1200&amp;q=75 1200w, ../_next/33-6.png 1920we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F33.png&amp;w=1920&amp;q=75 1920w, ../_next/33-7.png 2048we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F33.png&amp;w=2048&amp;q=75 2048w, ../_next/33.png 3840we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F33.png&amp;w=3840&amp;q=75 3840w" src="../_next/33.png?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F33.png&amp;w=3840&amp;q=75" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%" loading="lazy"></noscript></span></div>
<!-- --><p>First, we have to make sure that the <!-- --><span style="background-color:rgb(49 48 52 / 50%);padding:0.2rem 0.4rem;font-size:85%;margin:0.2rem;border-radius:0.2em;font-family:Menlo;font-weight:bolder"> <!-- -->getServerSideProps<!-- --></span> method doesn&#x27;t run too long. The page generation won&#x27;t start until this method has resolved with data that gets passed to the page.<!-- --></p>
<!-- --><div class="styles_divider__vbkkn"></div>
<!-- --><style>
                      .image-container {
                        width: 110%;
                        margin-bottom: 50px;
                      }

                      @media screen and (max-width: 767px) {
                        .image-container {
                          width: 95vw;
                        }
                      }

                    </style><div class="image-container"><span style="box-sizing:border-box;display:block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;padding-top:55.74468085106383%"></span><img alt="Flow chart" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%"><noscript><img alt="Flow chart" sizes="100vw" srcset="../_next/34-1.png 640w?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F34.png&amp;w=640&amp;q=75 640w, ../_next/34-2.png 750we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F34.png&amp;w=750&amp;q=75 750w, ../_next/34-3.png 828we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F34.png&amp;w=828&amp;q=75 828w, ../_next/34-4.png 1080we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F34.png&amp;w=1080&amp;q=75 1080w, ../_next/34-5.png 1200we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F34.png&amp;w=1200&amp;q=75 1200w, ../_next/34-6.png 1920we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F34.png&amp;w=1920&amp;q=75 1920w, ../_next/34-7.png 2048we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F34.png&amp;w=2048&amp;q=75 2048w, ../_next/34.png 3840we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F34.png&amp;w=3840&amp;q=75 3840w" src="../_next/34.png?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F34.png&amp;w=3840&amp;q=75" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%" loading="lazy"></noscript></span></div>
<!-- --><p>One thing to keep in mind (and that&#x27;s often the cause of a long <!-- --><span style="background-color:rgb(49 48 52 / 50%);padding:0.2rem 0.4rem;font-size:85%;margin:0.2rem;border-radius:0.2em;font-family:Menlo;font-weight:bolder"> <!-- -->getServerSideProps<!-- --></span> execution), is the <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">time it takes to query data from your database</strong>.<!-- --></p>
<!-- --><div class="jsx-2cb62b8d759e2a53"><div class="lazyload-wrapper styles_lazyload-wrapper__iNCqt"><div class="video-placeholder"><p>Loading Video...</p><p id="sub"><a href="https://res.cloudinary.com/dq8xfyhu4/video/upload/v1609691928/CS%20Visualized//CS%20Visualized/Screen_Recording_2022-05-05_at_5.38.55_PM_uwecig.jpg" target="_blank" rel="noreferrer">If it takes too long, you can click here to see the video in a new tab.</a></p></div></div></div>
<!-- --><p>If your serverless function is deployed in San Francisco, but your database is deployed in Tokyo, it can take a while to establish a connection and get the data. Instead, consider <!-- --><strong style="color:#EDB658;background:-webkit-linear-gradient(45deg, #EDB658, #E7719B);-webkit-background-clip:text;-webkit-text-fill-color:transparent">moving your database to the same region as your serverless function</strong> to ensure your database queries can be a lot faster.<!-- --></p>
<!-- --><div class="styles_divider__vbkkn"></div>
<!-- --><style>
                      .image-container {
                        width: 110%;
                        margin-bottom: 50px;
                      }

                      @media screen and (max-width: 767px) {
                        .image-container {
                          width: 95vw;
                        }
                      }

                    </style><div class="image-container"><span style="box-sizing:border-box;display:block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;padding-top:55.74468085106383%"></span><img alt="Flow chart" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%"><noscript><img alt="Flow chart" sizes="100vw" srcset="../_next/35-1.png 640w?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F35.png&amp;w=640&amp;q=75 640w, ../_next/35-2.png 750we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F35.png&amp;w=750&amp;q=75 750w, ../_next/35-3.png 828we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F35.png&amp;w=828&amp;q=75 828w, ../_next/35-4.png 1080we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F35.png&amp;w=1080&amp;q=75 1080w, ../_next/35-5.png 1200we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F35.png&amp;w=1200&amp;q=75 1200w, ../_next/35-6.png 1920we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F35.png&amp;w=1920&amp;q=75 1920w, ../_next/35-7.png 2048we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F35.png&amp;w=2048&amp;q=75 2048w, ../_next/35.png 3840we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F35.png&amp;w=3840&amp;q=75 3840w" src="../_next/35.png?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F35.png&amp;w=3840&amp;q=75" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%" loading="lazy"></noscript></span></div>
<!-- --><p>Next, you might improve your performance a bit by <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">adding</strong> <!-- --><span style="background-color:rgb(49 48 52 / 50%);padding:0.2rem 0.4rem;font-size:85%;margin:0.2rem;border-radius:0.2em;font-family:Menlo;font-weight:bolder"> <!-- -->Cache-Control<!-- --></span> <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">headers</strong> to the responses.<!-- --></p>
<!-- --><style>
                      .image-container {
                        width: 110%;
                        margin-bottom: 50px;
                      }

                      @media screen and (max-width: 767px) {
                        .image-container {
                          width: 95vw;
                        }
                      }

                    </style><div class="image-container"><span style="box-sizing:border-box;display:block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;padding-top:55.74468085106383%"></span><img alt="Flow chart" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%"><noscript><img alt="Flow chart" sizes="100vw" srcset="../_next/36-1.png 640w?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F36.png&amp;w=640&amp;q=75 640w, ../_next/36-2.png 750we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F36.png&amp;w=750&amp;q=75 750w, ../_next/36-3.png 828we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F36.png&amp;w=828&amp;q=75 828w, ../_next/36-4.png 1080we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F36.png&amp;w=1080&amp;q=75 1080w, ../_next/36-5.png 1200we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F36.png&amp;w=1200&amp;q=75 1200w, ../_next/36-6.png 1920we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F36.png&amp;w=1920&amp;q=75 1920w, ../_next/36-7.png 2048we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F36.png&amp;w=2048&amp;q=75 2048w, ../_next/36.png 3840we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F36.png&amp;w=3840&amp;q=75 3840w" src="../_next/36.png?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F36.png&amp;w=3840&amp;q=75" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%" loading="lazy"></noscript></span></div>
<!-- --><p>However, if you find yourself doing that, your page might work even better if you used <!-- --><strong style="color:#EDB658;background:-webkit-linear-gradient(45deg, #EDB658, #E7719B);-webkit-background-clip:text;-webkit-text-fill-color:transparent">(On-demand) Incremental Static Regeneration</strong>. Besides not having to manually take care of revalidation, the recomputed page will also be shared globally as opposed to one single region. <!-- --><strong style="color:#EDB658;background:-webkit-linear-gradient(45deg, #EDB658, #E7719B);-webkit-background-clip:text;-webkit-text-fill-color:transparent">(On-demand) Incremental Static Regeneration</strong> also ensures that your website is always online since there will <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">always be a cached version available</strong>, whereas <!-- --><strong style="color:#EDB658;background:-webkit-linear-gradient(45deg, #EDB658, #E7719B);-webkit-background-clip:text;-webkit-text-fill-color:transparent">Server-Side Rendering</strong> is <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">dependent on the availability of the lambda</strong>. If a region goes down, so does your website.<!-- --></p>
<!-- --><p>Since ISR does not allow you to use request-based data, <!-- --><strong style="color:#EDB658;background:-webkit-linear-gradient(45deg, #EDB658, #E7719B);-webkit-background-clip:text;-webkit-text-fill-color:transparent">SSR</strong> is still definitely the way to go if your page is using this.<!-- --></p>
<!-- --><div class="styles_divider__vbkkn"></div>
<!-- --><style>
                      .image-container {
                        width: 110%;
                        margin-bottom: 50px;
                      }

                      @media screen and (max-width: 767px) {
                        .image-container {
                          width: 95vw;
                        }
                      }

                    </style><div class="image-container"><span style="box-sizing:border-box;display:block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;padding-top:55.74468085106383%"></span><img alt="Flow chart" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%"><noscript><img alt="Flow chart" sizes="100vw" srcset="../_next/37-1.png 640w?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F37.png&amp;w=640&amp;q=75 640w, ../_next/37-2.png 750we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F37.png&amp;w=750&amp;q=75 750w, ../_next/37-3.png 828we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F37.png&amp;w=828&amp;q=75 828w, ../_next/37-4.png 1080we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F37.png&amp;w=1080&amp;q=75 1080w, ../_next/37-5.png 1200we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F37.png&amp;w=1200&amp;q=75 1200w, ../_next/37-6.png 1920we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F37.png&amp;w=1920&amp;q=75 1920w, ../_next/37-7.png 2048we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F37.png&amp;w=2048&amp;q=75 2048w, ../_next/37.png 3840we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F37.png&amp;w=3840&amp;q=75 3840w" src="../_next/37.png?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F37.png&amp;w=3840&amp;q=75" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%" loading="lazy"></noscript></span></div>
<!-- --><p>Next is something that is not as easy to do, namely <!-- --><strong style="color:#EDB658;background:-webkit-linear-gradient(45deg, #EDB658, #E7719B);-webkit-background-clip:text;-webkit-text-fill-color:transparent">upgrading the server hardware</strong> to get faster responses.<!-- --></p>
<!-- --><p>When you deploy to Vercel, we use serverless functions to server-render your pages.</p>
<!-- --><style>
                      .image-container {
                        width: 110%;
                        margin-bottom: 50px;
                      }

                      @media screen and (max-width: 767px) {
                        .image-container {
                          width: 95vw;
                        }
                      }

                    </style><div class="image-container"><span style="box-sizing:border-box;display:block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;padding-top:55.74468085106383%"></span><img alt="Flow chart" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%"><noscript><img alt="Flow chart" sizes="100vw" srcset="../_next/38-1.png 640w?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F38.png&amp;w=640&amp;q=75 640w, ../_next/38-2.png 750we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F38.png&amp;w=750&amp;q=75 750w, ../_next/38-3.png 828we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F38.png&amp;w=828&amp;q=75 828w, ../_next/38-4.png 1080we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F38.png&amp;w=1080&amp;q=75 1080w, ../_next/38-5.png 1200we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F38.png&amp;w=1200&amp;q=75 1200w, ../_next/38-6.png 1920we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F38.png&amp;w=1920&amp;q=75 1920w, ../_next/38-7.png 2048we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F38.png&amp;w=2048&amp;q=75 2048w, ../_next/38.png 3840we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F38.png&amp;w=3840&amp;q=75 3840w" src="../_next/38.png?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F38.png&amp;w=3840&amp;q=75" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%" loading="lazy"></noscript></span></div>
<!-- --><p>Although serverless functions come with many benefits, such as only having to pay for what you use, there are a few limitations. A common issue is the <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">long cold boot</strong>, meaning the time it takes to start up the lambda, and <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">slow connections to databases</strong>. It’s also not great to call a serverless function all the way on the west coast if you’re located on the other side of the planet.<!-- --></p>
<!-- --><style>
                      .image-container {
                        width: 110%;
                        margin-bottom: 50px;
                      }

                      @media screen and (max-width: 767px) {
                        .image-container {
                          width: 95vw;
                        }
                      }

                    </style><div class="image-container"><span style="box-sizing:border-box;display:block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;padding-top:55.74468085106383%"></span><img alt="Flow chart" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%"><noscript><img alt="Flow chart" sizes="100vw" srcset="../_next/39-1.png 640w?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F39.png&amp;w=640&amp;q=75 640w, ../_next/39-2.png 750we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F39.png&amp;w=750&amp;q=75 750w, ../_next/39-3.png 828we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F39.png&amp;w=828&amp;q=75 828w, ../_next/39-4.png 1080we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F39.png&amp;w=1080&amp;q=75 1080w, ../_next/39-5.png 1200we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F39.png&amp;w=1200&amp;q=75 1200w, ../_next/39-6.png 1920we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F39.png&amp;w=1920&amp;q=75 1920w, ../_next/39-7.png 2048we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F39.png&amp;w=2048&amp;q=75 2048w, ../_next/39.png 3840we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F39.png&amp;w=3840&amp;q=75 3840w" src="../_next/39.png?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F39.png&amp;w=3840&amp;q=75" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%" loading="lazy"></noscript></span></div>
<!-- --><p>We&#x27;re currently exploring <!-- --><strong style="color:#EDB658;background:-webkit-linear-gradient(45deg, #EDB658, #E7719B);-webkit-background-clip:text;-webkit-text-fill-color:transparent">Edge Server-Side Rendering</strong>, which enables users to <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">server-render from all regions</strong>, and experience a <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">near-zero cold boot</strong>. Another huge benefit of <!-- --><strong style="color:#EDB658;background:-webkit-linear-gradient(45deg, #EDB658, #E7719B);-webkit-background-clip:text;-webkit-text-fill-color:transparent">Edge SSR</strong>, is the fact that the edge runtime also allows for <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">HTTP streaming</strong>.<!-- --></p>
<!-- --><div class="jsx-2cb62b8d759e2a53"><div class="lazyload-wrapper styles_lazyload-wrapper__iNCqt"><div class="video-placeholder"><p>Loading Video...</p><p id="sub"><a href="https://res.cloudinary.com/dq8xfyhu4/video/upload/v1609691928/CS%20Visualized//CS%20Visualized/Screen_Recording_2022-05-05_at_5.47.07_PM_usqexj.jpg" target="_blank" rel="noreferrer">If it takes too long, you can click here to see the video in a new tab.</a></p></div></div></div>
<!-- --><p>With serverless functions, we had to generate the entire page server-side, and <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">wait for the entire bundle</strong> to be loaded and parsed on the client before hydration could begin.<!-- --></p>
<!-- --><div class="jsx-2cb62b8d759e2a53"><div class="lazyload-wrapper styles_lazyload-wrapper__iNCqt"><div class="video-placeholder"><p>Loading Video...</p><p id="sub"><a href="https://res.cloudinary.com/dq8xfyhu4/video/upload/v1609691928/CS%20Visualized//CS%20Visualized/Screen_Recording_2022-05-05_at_5.48.20_PM_auurip.jpg" target="_blank" rel="noreferrer">If it takes too long, you can click here to see the video in a new tab.</a></p></div></div></div>
<!-- --><p>With <!-- --><strong style="color:#EDB658;background:-webkit-linear-gradient(45deg, #EDB658, #E7719B);-webkit-background-clip:text;-webkit-text-fill-color:transparent">Edge SSR</strong>, we can <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">stream parts of the document as soon as they&#x27;re ready</strong>, and <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">hydrate these components granularly</strong>. This means that users no longer have to wait for a longer time before they can see anything on the screen, as the components stream in one by one.<!-- --></p>
<!-- --><style>
                      .image-container {
                        width: 110%;
                        margin-bottom: 50px;
                      }

                      @media screen and (max-width: 767px) {
                        .image-container {
                          width: 95vw;
                        }
                      }

                    </style><div class="image-container"><span style="box-sizing:border-box;display:block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;padding-top:55.74468085106383%"></span><img alt="Flow chart" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%"><noscript><img alt="Flow chart" sizes="100vw" srcset="../_next/40-1.png 640w?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F40.png&amp;w=640&amp;q=75 640w, ../_next/40-2.png 750we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F40.png&amp;w=750&amp;q=75 750w, ../_next/40-3.png 828we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F40.png&amp;w=828&amp;q=75 828w, ../_next/40-4.png 1080we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F40.png&amp;w=1080&amp;q=75 1080w, ../_next/40-5.png 1200we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F40.png&amp;w=1200&amp;q=75 1200w, ../_next/40-6.png 1920we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F40.png&amp;w=1920&amp;q=75 1920w, ../_next/40-7.png 2048we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F40.png&amp;w=2048&amp;q=75 2048w, ../_next/40.png 3840we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F40.png&amp;w=3840&amp;q=75 3840w" src="../_next/40.png?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F40.png&amp;w=3840&amp;q=75" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%" loading="lazy"></noscript></span></div>
<!-- --><p><strong style="color:#EDB658;background:-webkit-linear-gradient(45deg, #EDB658, #E7719B);-webkit-background-clip:text;-webkit-text-fill-color:transparent">Streaming SSR</strong> also enables <!-- --><strong style="color:#EDB658;background:-webkit-linear-gradient(45deg, #EDB658, #E7719B);-webkit-background-clip:text;-webkit-text-fill-color:transparent">React Server Components</strong>. Now I&#x27;m not going into the nitty gritty details of <!-- --><strong style="color:#EDB658;background:-webkit-linear-gradient(45deg, #EDB658, #E7719B);-webkit-background-clip:text;-webkit-text-fill-color:transparent">React Server Components</strong>, but the combination of <!-- --><strong style="color:#EDB658;background:-webkit-linear-gradient(45deg, #EDB658, #E7719B);-webkit-background-clip:text;-webkit-text-fill-color:transparent">Edge SSR with React Server Components</strong> can allow us to have a beautiful <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">hybrid between static and server rendering</strong>.<!-- --></p>
<!-- --><p><strong style="color:#EDB658;background:-webkit-linear-gradient(45deg, #EDB658, #E7719B);-webkit-background-clip:text;-webkit-text-fill-color:transparent">React Server Components</strong> allow us to partially render React components on the server, which is especially useful for components that require large dependencies, as we no longer have to download these dependencies on the client.<!-- --></p>
<!-- --><style>
                      .image-container {
                        width: 110%;
                        margin-bottom: 50px;
                      }

                      @media screen and (max-width: 767px) {
                        .image-container {
                          width: 95vw;
                        }
                      }

                    </style><div class="image-container"><span style="box-sizing:border-box;display:block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;padding-top:55.74468085106383%"></span><img alt="Flow chart" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%"><noscript><img alt="Flow chart" sizes="100vw" srcset="../_next/41-1.png 640w?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F41.png&amp;w=640&amp;q=75 640w, ../_next/41-2.png 750we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F41.png&amp;w=750&amp;q=75 750w, ../_next/41-3.png 828we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F41.png&amp;w=828&amp;q=75 828w, ../_next/41-4.png 1080we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F41.png&amp;w=1080&amp;q=75 1080w, ../_next/41-5.png 1200we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F41.png&amp;w=1200&amp;q=75 1200w, ../_next/41-6.png 1920we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F41.png&amp;w=1920&amp;q=75 1920w, ../_next/41-7.png 2048we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F41.png&amp;w=2048&amp;q=75 2048w, ../_next/41.png 3840we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F41.png&amp;w=3840&amp;q=75 3840w" src="../_next/41.png?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F41.png&amp;w=3840&amp;q=75" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%" loading="lazy"></noscript></span></div>
<!-- --><p>For example if we wanted to show the landing page again, but this time we wanted to show region-specific listings to the user. The vast majority of the page only contains static data, it&#x27;s just the listings that require request-based data.</p>
<!-- --><p>Instead of having to server-render the entire page, we can now choose to <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">only render the listings component server-side</strong>, and the rest client-side. Whereas we initially had to server-render the entire page to achieve this behavior, we can now get the <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">great performance of</strong> <!-- --><strong style="color:#EDB658;background:-webkit-linear-gradient(45deg, #EDB658, #E7719B);-webkit-background-clip:text;-webkit-text-fill-color:transparent">Static Rendering</strong> <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">, with the dynamic benefits of</strong> <!-- --><strong style="color:#EDB658;background:-webkit-linear-gradient(45deg, #EDB658, #E7719B);-webkit-background-clip:text;-webkit-text-fill-color:transparent">Server-Side Rendering</strong>.<!-- --></p>
<!-- --><style>
                      .image-container {
                        width: 110%;
                        margin-bottom: 50px;
                      }

                      @media screen and (max-width: 767px) {
                        .image-container {
                          width: 95vw;
                        }
                      }

                    </style><div class="image-container"><span style="box-sizing:border-box;display:block;overflow:hidden;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;position:relative"><span style="box-sizing:border-box;display:block;width:initial;height:initial;background:none;opacity:1;border:0;margin:0;padding:0;padding-top:55.74468085106383%"></span><img alt="Flow chart" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%"><noscript><img alt="Flow chart" sizes="100vw" srcset="../_next/42-1.png 640w?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F42.png&amp;w=640&amp;q=75 640w, ../_next/42-2.png 750we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F42.png&amp;w=750&amp;q=75 750w, ../_next/42-3.png 828we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F42.png&amp;w=828&amp;q=75 828w, ../_next/42-4.png 1080we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F42.png&amp;w=1080&amp;q=75 1080w, ../_next/42-5.png 1200we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F42.png&amp;w=1200&amp;q=75 1200w, ../_next/42-6.png 1920we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F42.png&amp;w=1920&amp;q=75 1920w, ../_next/42-7.png 2048we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F42.png&amp;w=2048&amp;q=75 2048w, ../_next/42.png 3840we?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F42.png&amp;w=3840&amp;q=75 3840w" src="../_next/42.png?url=%2Fimages%2Ftalks%2Fadvanced-rendering-patterns%2F42.png&amp;w=3840&amp;q=75" decoding="async" data-nimg="responsive" style="background-color:#000;position:absolute;top:0;left:0;bottom:0;right:0;box-sizing:border-box;padding:0;border:none;margin:auto;display:block;width:0;height:0;min-width:100%;max-width:100%;min-height:100%;max-height:100%;object-fit:contain;object-position:50% 50%" loading="lazy"></noscript></span></div>
<!-- --><p>Although we&#x27;ve just covered many patterns to choose from, knowing which pattern makes the most sense for your use case can give your application huge performance benefits. On Vercel, you can opt into these techniques on a per-page basis, making it <!-- --><strong style="color:#51B2F3;background:-webkit-linear-gradient(45deg, #51B2F3, #A8EAB1);-webkit-background-clip:text;-webkit-text-fill-color:transparent">extremely easy to scale without running into performance issues</strong> when your application grows.<!-- --></p>
<!-- --><p><strong style="color:#EDB658;background:-webkit-linear-gradient(45deg, #EDB658, #E7719B);-webkit-background-clip:text;-webkit-text-fill-color:transparent">Static Rendering</strong> and <!-- --><strong style="color:#EDB658;background:-webkit-linear-gradient(45deg, #EDB658, #E7719B);-webkit-background-clip:text;-webkit-text-fill-color:transparent">Server Rendering</strong> both have their place in the world, and we&#x27;re working on a future where we we can create highly personalized websites with great performance. The web is extremely powerful, and it’s only getting better, especially with an Edge-first approach to look forward to!<!-- --></p></div></section></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"mdx":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      blockquote: \"blockquote\",\n      p: \"p\",\n      hr: \"hr\",\n      strong: \"strong\",\n      em: \"em\",\n      code: \"code\"\n    }, _provideComponents(), props.components), {LazyLoad, Blue, LocalImage, Video} = _components;\n    if (!Blue) _missingMdxReference(\"Blue\", true);\n    if (!LazyLoad) _missingMdxReference(\"LazyLoad\", true);\n    if (!LocalImage) _missingMdxReference(\"LocalImage\", true);\n    if (!Video) _missingMdxReference(\"Video\", true);\n    return _jsxs(_Fragment, {\n      children: [_jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"This article is a transcript with slides of a talk I gave at Reactathon on May 3rd, 2022.\"\n        }), \"\\n\", _jsx(LazyLoad, {\n          height: 315,\n          offset: 100,\n          children: _jsx(\"iframe\", {\n            width: \"560\",\n            height: \"315\",\n            src: \"https://www.youtube.com/embed/PN1HgvAOmi8\",\n            title: \"YouTube video player\",\n            frameborder: \"0\",\n            allow: \"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\",\n            allowfullscreen: true\n          })\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Building on the web has never been more powerful than it is in 2022, and which patterns make the most sense for your use case can give your application huge performance benefits.\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Now I'm not here to talk bad about certain patterns and praise others, it's just here to cover some common patterns we see nowadays and \", _jsx(Blue, {\n          children: \"their tradeoffs for specific use cases\"\n        }), \"!\"]\n      }), \"\\n\", _jsx(LocalImage, {\n        src: \"/images/talks/advanced-rendering-patterns/2.png\",\n        priority: true\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Ideally, we just want to develop, preview, ship, impress users, and change the world with our revolutionary ideas.\"\n      }), \"\\n\", _jsx(LocalImage, {\n        src: \"/images/talks/advanced-rendering-patterns/3.png\",\n        priority: true\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Unfortunately, in most cases, it doesn't quite end up this way. We might accidentally introduce really \", _jsx(Blue, {\n          children: \"long build times\"\n        }), \", \", _jsx(Blue, {\n          children: \"frustrate our users\"\n        }), \" because the website loads real slow or has a jumpy UI, and get with a \", _jsx(Blue, {\n          children: \"huge server bill\"\n        }), \" at the end of the month for a project that didn't even gain traction, as the website never got a great SEO due to bad performance.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Although our idea might have changed the world, the way that we architected our project prevented this from ever happening!\"\n      }), \"\\n\", _jsx(LocalImage, {\n        src: \"/images/talks/advanced-rendering-patterns/4.1.png\",\n        priority: true\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"So... what can we do about this?\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"We have to start implementing the right rendering patterns in our applications! Knowing how to apply these techniques can massively improve your app's performance, giving you a great product to share with the world.\"\n      }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.p, {\n        children: [\"Usually when we talk about web performance, we think about optimizing for the \", _jsx(Blue, {\n          children: \"Core Web Vitals\"\n        }), \".\"]\n      }), \"\\n\", _jsx(LocalImage, {\n        src: \"/images/talks/advanced-rendering-patterns/1.png\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"These are a \", _jsx(Blue, {\n          children: \"set of useful measurements\"\n        }), \" that tell us how well our site performs, for example the \", _jsx(Blue, {\n          children: \"TTFB\"\n        }), \" measures the time it takes for the server to respond with the initial data, and the \", _jsx(Blue, {\n          children: \"FCP\"\n        }), \" measures how quickly your users see useful content on their screen for the first time, and so on, I won't go over all of these right now.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"If we want to have a website with \", _jsx(Blue, {\n          children: \"great user experience and optimal SEO\"\n        }), \", we have to start caring about optimizing for these measurements.\"]\n      }), \"\\n\", _jsx(LocalImage, {\n        src: \"/images/talks/advanced-rendering-patterns/5.png\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"But that’s not all,  we also want to have the best developer experience!\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"We want a project with \", _jsx(Blue, {\n          children: \"short build times\"\n        }), \" to be able to quickly iterate, \", _jsx(Blue, {\n          children: \"low server costs\"\n        }), \" so we don’t go bankrupt, show \", _jsx(Blue, {\n          children: \"dynamic content\"\n        }), \" in a performant way if needed, and generally \", _jsx(Blue, {\n          children: \"no scalability issues\"\n        }), \" further down the line when our website goes viral.\"]\n      }), \"\\n\", _jsx(LocalImage, {\n        src: \"/images/talks/advanced-rendering-patterns/6.png\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Although this seems like a lot to keep in mind, using the right rendering technique can really help you out here to create a great user and developer experience.\"\n      }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.p, {\n        children: \"Now that we know why rendering patterns are imporant, how do you know which ones make the most sense for your website? Or if you're using Vercel, you can even choose this on a per-page basis, so which one makes the most sense for that specific page?\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Spending one minute on Google or on tech twitter can already feel pretty overwhelming with all new terms, abbreviations and the latest trendy ways to render data, and people’s opinion on them.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"All patterns out there have their use case, there is not one pattern that’s better than the others, as long as you know their tradeoffs.\"\n      }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(LocalImage, {\n        src: \"/images/talks/advanced-rendering-patterns/img1.png\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"First, let’s talk about a pattern that may seem very basic and straight-forward, namely \", _jsx(_components.strong, {\n          children: \"Static Rendering\"\n        }), \".\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Although it might seem simple, there are many variations to static rendering to serve a lot of different use cases. Static rendering is popular pattern as it comes with so many performance benefits.\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"With static rendering, the \", _jsx(Blue, {\n          children: \"entire HTML gets generated at build time\"\n        }), \".\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Since the files are static, they’re \", _jsx(Blue, {\n          children: \"easily cacheable by a CDN\"\n        }), \", or on Vercel by the Edge Network. This makes it possible to get \", _jsx(Blue, {\n          children: \"extremely fast responses\"\n        }), \", since the CDN can quickly return the cached file instead of having to request it from the origin server.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"There are many variations to static rendering to serve a lot of different use cases.\"\n      }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(LocalImage, {\n        src: \"/images/talks/advanced-rendering-patterns/img1.jpeg\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"First up is \", _jsx(_components.strong, {\n          children: \"Plain Static Rendering\"\n        }), \" (\", _jsx(_components.em, {\n          children: \"I'm just calling it plain static rendering since I couldn't really think of a better term lol, not sure if there is one\"\n        }), \").\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.strong, {\n          children: \"Plain Static Rendering\"\n        }), \" is a technique we can use for \", _jsx(Blue, {\n          children: \"very non-dynamic pages\"\n        }), \", such as the landing page of this fake demo real estate website.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"This page is absolutely perfect for \", _jsx(_components.strong, {\n          children: \"static rendering\"\n        }), \" as it just shows the \", _jsx(Blue, {\n          children: \"same data for everyone globally\"\n        }), \". We aren’t fetching any data or showing any personalized components.\"]\n      }), \"\\n\", _jsx(Video, {\n        src: \"Screen_Recording_2022-05-05_at_10.10.58_AM_umtlyl\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"When we deploy this, in this case to Vercel, the HTML gets generated for the pages, and persisted to static storage.\"\n      }), \"\\n\", _jsx(Video, {\n        src: \"Screen_Recording_2022-05-05_at_10.18.37_AM_bhybvb\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"When a user visits the website, a request is made to the server.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"The server can quickly return the pre-generated HTML to the client, and as it gets returned, the Edge location closest to the user caches the response.\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"The browser renders the HTML, and requests a JavaScript bundle to hydrate the page. (\", _jsx(_components.em, {\n          children: \"Hydration is the process of binding event handlers to the HTML elements to make them interactive\"\n        }), \")\"]\n      }), \"\\n\", _jsx(LocalImage, {\n        src: \"/images/talks/advanced-rendering-patterns/7.png\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"From a performance perspective, this is a great approach!\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"We can have an \", _jsx(Blue, {\n          children: \"extremely quick TTFB\"\n        }), \" since the server already contains the pre-generated HTML, and the browser can quickly render something to the screen, resulting in a \", _jsx(Blue, {\n          children: \"fast FCP and LCP\"\n        }), \".  We also \", _jsx(Blue, {\n          children: \"don’t have to worry about layout shift\"\n        }), \" since we’re not dynamically loading components.\"]\n      }), \"\\n\", _jsx(LocalImage, {\n        src: \"/images/talks/advanced-rendering-patterns/8.png\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.strong, {\n          children: \"Plain Static Rendering\"\n        }), \" is great for your Core Web Vitals, especially in combination with a CDN. However, in most cases, we'll probably want to show some dynamic data.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Say that instead of showing some services here, we actually want to show some recent listings. We \", _jsx(_components.em, {\n          children: \"could\"\n        }), \" just hard-code that data right in the page, but in reality we’re probably using some data provider to get our listings from.\"]\n      }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(LocalImage, {\n        src: \"/images/talks/advanced-rendering-patterns/9.png\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"One approach we can take here, is to use \", _jsx(_components.strong, {\n          children: \"Static Rendering with Client-Side\"\n        }), \" \", _jsx(_components.code, {\n          children: \"fetch\"\n        }), \". This is usually a great pattern for pages that contain \", _jsx(Blue, {\n          children: \"data that should be updated on every request\"\n        }), \".\"]\n      }), \"\\n\", _jsx(LocalImage, {\n        src: \"/images/talks/advanced-rendering-patterns/10.png\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"We can statically render the website like we did before,  and fetch the data using for example SWR on the client as soon as the page has loaded. While the data is being fetched, we’ll show a skeleton component.\"\n      }), \"\\n\", _jsx(LocalImage, {\n        src: \"/images/talks/advanced-rendering-patterns/11.png\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"We also need create a custom API route to fetch the data from. Within the API route, we retrieve the data from our CMS, and return this data.\"\n      }), \"\\n\", _jsx(Video, {\n        src: \"Screen_Recording_2022-05-05_at_2.55.30_PM_r0jvez\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Now when the user request the page, the server again returns with the pre-generated HTML file. The user initially sees the skeleton UI since the data hasn't been fetched yet.\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"After parsing and rendering the initial content, the client fetches the data from the API route, and after getting a successful response, we can finally show the listings. \", _jsx(_components.em, {\n          children: \"(For simplicity, I'm not including the hydration call in this example)\"\n        })]\n      }), \"\\n\", _jsx(LocalImage, {\n        src: \"/images/talks/advanced-rendering-patterns/12.png\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Although using \", _jsx(_components.strong, {\n          children: \"Static Rendering with Client-Side\"\n        }), \" \", _jsx(_components.code, {\n          children: \"fetch\"\n        }), \" gives us a \", _jsx(Blue, {\n          children: \"good TTFB and FCP\"\n        }), \", the \", _jsx(Blue, {\n          children: \"LCP is not as good\"\n        }), \" as it used to be, since we have to wait for the API route to return data in order to show the listings.\"]\n      }), \"\\n\", _jsx(LocalImage, {\n        src: \"/images/talks/advanced-rendering-patterns/13.png\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"We might also \", _jsx(Blue, {\n          children: \"run into layout shifts\"\n        }), \", which can happen if our skeleton component doesn't match with the content that eventually gets rendered after receiving the data.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Since we're calling the API route on every page request, we can also run into \", _jsx(Blue, {\n          children: \"higher server costs\"\n        }), \" as we pay for every execution.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"When you use Next.js, you can actually choose between a few more static approaches that really improve the performance of your app when working with dynamic data.\"\n      }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(LocalImage, {\n        src: \"/images/talks/advanced-rendering-patterns/14.png\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"The first approach, is using \", _jsx(_components.strong, {\n          children: \"Static with\"\n        }), \" \", _jsx(_components.code, {\n          children: \"getStaticProps\"\n        }), \". This method runs \", _jsx(Blue, {\n          children: \"server-side at build time\"\n        }), \", meaning that we can directly call our data provider within this method. If your data is available at build time, this can be a really good solution to add dynamic data to a static page.\"]\n      }), \"\\n\", _jsx(LocalImage, {\n        src: \"/images/talks/advanced-rendering-patterns/15.png\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Since the \", _jsx(_components.code, {\n          children: \"getStaticProps\"\n        }), \" method runs server-side, we no longer have to deal with custom API Routes to fetch the data from, we can do this directly within the method.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"We also no longer have to show a skeleton component, as there will never be a loading state; the \", _jsx(Blue, {\n          children: \"generated HTML already contains the fetched data\"\n        }), \".\"]\n      }), \"\\n\", _jsx(Video, {\n        src: \"Screen_Recording_2022-05-05_at_3.02.04_PM_avmzuy\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"When we build the project, the data provider gets called, and the returned data gets passed to the generated HTML.\"\n      }), \"\\n\", _jsx(Video, {\n        src: \"Screen_Recording_2022-05-05_at_3.06.26_PM_djvt57\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Now when we request the page, we again fetch the HTML from the server. The response gets cached, rendered to the screen, and the browser again sends a request to fetch the JS bundles in order to hydrate the elements.\"\n      }), \"\\n\", _jsx(LocalImage, {\n        src: \"/images/talks/advanced-rendering-patterns/16.png\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"The network and main thread work are identical to what we saw before when we just statically rendered the content without injecting any data at build time, so from a user perspective, we again get a \", _jsx(Blue, {\n          children: \"great performance\"\n        }), \".\"]\n      }), \"\\n\", _jsx(LocalImage, {\n        src: \"/images/talks/advanced-rendering-patterns/17.png\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"However, as a developer, you can quickly run into some issues.\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Imagine if we statically built hundreds of pages, which can easily happen on a blog or ecommerce website, and we’re calling the \", _jsx(_components.code, {\n          children: \"getStaticProps\"\n        }), \" method for all these pages.  This can result in \", _jsx(Blue, {\n          children: \"really long build times\"\n        }), \", and if you’re using an external API, you can even \", _jsx(Blue, {\n          children: \"hit the request limit\"\n        }), \" pretty fast, or get charged a lot of money if they charge per request.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Another issue is that we’re \", _jsx(Blue, {\n          children: \"only renewing the data at build time\"\n        }), \", meaning we’d have to redeploy the website to update the content.\"]\n      }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(LocalImage, {\n        src: \"/images/talks/advanced-rendering-patterns/18.png\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Luckily, we can use \", _jsx(_components.strong, {\n          children: \"Incremental Static Regeneration\"\n        }), \" to solve our build time and dynamic data issues.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"With ISR, we can decide to \", _jsx(Blue, {\n          children: \"only pre-render certain pages\"\n        }), \", and render the other pages on-demand when the user requests them, resulting in much shorter build times. It also allows us to \", _jsx(Blue, {\n          children: \"automatically invalidate the cache and regenerate the page\"\n        }), \" after a certain interval.\"]\n      }), \"\\n\", _jsx(LocalImage, {\n        src: \"/images/talks/advanced-rendering-patterns/19.png\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Imagine if we wanted to be able to show individual listings as well, and pre-render these pages to get great performance when a user clicks on a listing.\"\n      }), \"\\n\", _jsx(LocalImage, {\n        src: \"/images/talks/advanced-rendering-patterns/20.png\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Using Next.js, we can have dynamic paths with the combination of \", _jsx(_components.code, {\n          children: \"getStaticPaths\"\n        }), \" to tell Next.js which pages to pre-generate, based on their query parameter.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"In this case, we're fetching all listings and pre-generating the pages for each and every one of them. If we had thousands of listings, this would take a really long time to finish.\"\n      }), \"\\n\", _jsx(LocalImage, {\n        src: \"/images/talks/advanced-rendering-patterns/21.png\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Instead, we can tell Next to only pre-generate a subset of all the pages, and render a fallback while the listing is page generated on-demand.\"\n      }), \"\\n\", _jsx(Video, {\n        src: \"Screen_Recording_2022-05-05_at_3.49.59_PM_deygni\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"The pre-rendered pages behave the exact same. If a user requests a page that hasn't been generated yet, it gets generated on-demand, after which it \", _jsx(Blue, {\n          children: \"automatically gets cached by the edge\"\n        }), \". That means that only the first user might have a worse experience as the page still needs to be generated, but everyone else can benefit from getting a fast, cached response.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Our long build times have been solved, but we still don’t want to have to redeploy the landing page every time to renew the data with the latest listings.\"\n      }), \"\\n\", _jsx(LocalImage, {\n        src: \"/images/talks/advanced-rendering-patterns/22.png\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Instead of only renewing the data at build time, we can automatically invalidate the cache and regenerate the page in the background on a certain interval. We can use this by \", _jsx(Blue, {\n          children: \"adding a\"\n        }), \" \", _jsx(_components.code, {\n          children: \"revalidate\"\n        }), \" \", _jsx(Blue, {\n          children: \"field\"\n        }), \" to the returned object.\"]\n      }), \"\\n\", _jsx(Video, {\n        src: \"updated_jvhqnv\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Now when a user requests a stale page, meaning a page that has been cached for longer than the specified number of seconds, the user gets to see a stale page at first. In the background, a \", _jsx(Blue, {\n          children: \"page regeneration is triggered\"\n        }), \" while the user gets to see the stale page.  Once the page has been regenerated in the background, the \", _jsx(Blue, {\n          children: \"cache gets invalidated and updated with the latest page\"\n        }), \".\"]\n      }), \"\\n\", _jsx(Video, {\n        src: \"Screen_Recording_2022-05-05_at_4.59.00_PM_ukri1c\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"When the user requests the page again, for example by refreshing it, they’ll see the updated content.\"\n      }), \"\\n\", _jsx(LocalImage, {\n        src: \"/images/talks/advanced-rendering-patterns/23.png\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"With \", _jsx(_components.strong, {\n          children: \"Incremental Static Regeneration\"\n        }), \", we can show dynamic content by automatically revalidating the page every number of seconds.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Although this is already a huge improvement to what we had before, we can run into some issues here. It's likely that our content doesn’t update every number of seconds, which would mean that we’re \", _jsx(Blue, {\n          children: \"unnecessarily regenerating the page and invalidating the cache\"\n        }), \" every number of seconds. Every time, we're invoking our serverless functions, which could result in \", _jsx(Blue, {\n          children: \"higher server costs\"\n        }), \".\"]\n      }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(LocalImage, {\n        src: \"/images/talks/advanced-rendering-patterns/24.png\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"The best option here, is to use \", _jsx(_components.strong, {\n          children: \"On-demand Incremental Static Regeneration\"\n        }), \".\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.strong, {\n          children: \"On-demand ISR\"\n        }), \" allows us to use \", _jsx(_components.strong, {\n          children: \"ISR\"\n        }), \", but instead of regenerating on a certain interval, we can \", _jsx(Blue, {\n          children: \"base the regeneration on certain events\"\n        }), \".\"]\n      }), \"\\n\", _jsx(LocalImage, {\n        src: \"/images/talks/advanced-rendering-patterns/25.png\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Instead of relying on the \", _jsx(_components.code, {\n          children: \"revalidate\"\n        }), \" field, we can manually \", _jsx(Blue, {\n          children: \"revalidate pages in API routes based on incoming requests\"\n        }), \".\"]\n      }), \"\\n\", _jsx(Video, {\n        src: \"Screen_Recording_2022-05-05_at_5.24.13_PM_xeumhu\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"For example, we can listen to an incoming webhook event that tells us when new data has been added to our data provider. When we invoke the revalidate method, the page on the specified path \", _jsx(Blue, {\n          children: \"automatically gets regenerated\"\n        }), \".\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Another huge benefit of using \", _jsx(_components.strong, {\n          children: \"on-demand ISR\"\n        }), \" over \", _jsx(_components.strong, {\n          children: \"regular ISR\"\n        }), \", is the fact that the newly generated page gets \", _jsx(Blue, {\n          children: \"distributed throughout the entire edge network\"\n        }), \"! With \", _jsx(_components.strong, {\n          children: \"regular ISR\"\n        }), \", the returned response only gets cached in the regions where users sent requests from.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"However, with \", _jsx(_components.strong, {\n          children: \"on-demand ISR\"\n        }), \", users from all over the world will \", _jsx(Blue, {\n          children: \"automatically hit the edge cache, without ever seeing stale content\"\n        }), \".  We also don’t have to worry about unnecessarily invoking a serverless function every number of seconds if content hasn’t been updated, making it a much cheaper pattern to use.\"]\n      }), \"\\n\", _jsx(LocalImage, {\n        src: \"/images/talks/advanced-rendering-patterns/26.png\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.strong, {\n          children: \"On-demand ISR\"\n        }), \" gives us all the \", _jsx(Blue, {\n          children: \"performance benefits\"\n        }), \", combined with a \", _jsx(Blue, {\n          children: \"great developer experience\"\n        }), \". We don't have to worry about high server costs as long as we don't trigger a revalidation too often, and we can bring a great performance to users all over the world in combination with the edge cache.\"]\n      }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(LocalImage, {\n        src: \"/images/talks/advanced-rendering-patterns/27.png\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.strong, {\n          children: \"Static generation\"\n        }), \" is an amazing pattern that can be used for tons of use cases, especially in combination with \", _jsx(_components.strong, {\n          children: \"ISR\"\n        }), \".\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"We can have an incredibly fast and dynamic website, that's also \", _jsx(Blue, {\n          children: \"always online\"\n        }), \", since there’s always a cached version available, and we end up with lower costs.\"]\n      }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsxs(_components.p, {\n        children: [\"However, there are also tons of use cases where static isn’t the best way to go, for example for \", _jsx(Blue, {\n          children: \"highly dynamic, personalized pages\"\n        }), \" that are \", _jsx(Blue, {\n          children: \"different for every user\"\n        }), \".\"]\n      }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(LocalImage, {\n        src: \"/images/talks/advanced-rendering-patterns/28.png\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"In that case, we might want to use \", _jsx(_components.strong, {\n          children: \"Server-Side Rendering\"\n        }), \". Whereas we generated the HTML at build time using static generation, with server-side rendering, we \", _jsx(Blue, {\n          children: \"generate the HTML on every request\"\n        }), \".\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"This can be a great approach for pages that contain highly personalized data, for example data based on the user cookie, or just generally any \", _jsx(Blue, {\n          children: \"data that's contained within the user's request\"\n        }), \". It's also good for pages that should be \", _jsx(Blue, {\n          children: \"render-blocking\"\n        }), \", perhaps based on authentication state.\"]\n      }), \"\\n\", _jsx(LocalImage, {\n        src: \"/images/talks/advanced-rendering-patterns/29.png\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"An example of a highly dynamic page is anything that requires a user cookie, is a dashboard. This dashboard is only shown when a user is authenticated, and shows mainly user-specific data.\"\n      }), \"\\n\", _jsx(LocalImage, {\n        src: \"/images/talks/advanced-rendering-patterns/30.png\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"With Next.js, we can \", _jsxs(_components.strong, {\n          children: [\"server-render a page using the \", _jsx(_components.code, {\n            children: \"getServerSideProps\"\n          }), \" method\"]\n        }), \". This method runs server-side on every request, and eventually passes the returned data to the page in order to generate the HTML.\"]\n      }), \"\\n\", _jsx(Video, {\n        src: \"Screen_Recording_2022-05-05_at_5.31.41_PM_oxsq12\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"When a user requests the page, the \", _jsx(_components.code, {\n          children: \"getServerSideProps\"\n        }), \" method runs, after which the page gets generated, and sent to the client. The client can quickly render this HTML, and can send an another request to fetch the JavaScript bundle to hydrate the elements.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"The generated pages are unique to every request, meaning they \", _jsx(_components.strong, {\n          children: \"aren’t automatically cached by our CDN\"\n        }), \".  Although this is the expected behavior,  there’s more to take into consideration if you want to get a good performance.\"]\n      }), \"\\n\", _jsx(LocalImage, {\n        src: \"/images/talks/advanced-rendering-patterns/31.png\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"When we look at the network and main thread, it looks pretty similar to what we initially saw with static rendering. The FCP is basically equal to the LCP, and we can easily avoid layout shift, as we're not dynamically rendering content.\"\n      }), \"\\n\", _jsx(Video, {\n        src: \"Screen_Recording_2022-05-05_at_5.36.49_PM_kkuxv3\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"However, when we compare static rendering an server rendering, you can see that the TTFB can be very short when we statically render data since it's already pre-generated. If a page is server-rendered however, the \", _jsx(_components.strong, {\n          children: \"TTFB can be a lot longer\"\n        }), \", as it still needs to be generated.\"]\n      }), \"\\n\", _jsx(LocalImage, {\n        src: \"/images/talks/advanced-rendering-patterns/32.png\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Although server-rendering is a great method when you want to render highly personalized data, there are some things to take into consideration to achieve a great user experience.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"We might also run into way higher server costs, which in some cases is completely worth it, but there are a few things you can do as a user to optimize your SSR performance!\"\n      }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(LocalImage, {\n        src: \"/images/talks/advanced-rendering-patterns/33.png\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"First, we have to make sure that the \", _jsx(_components.code, {\n          children: \"getServerSideProps\"\n        }), \" method doesn't run too long. The page generation won't start until this method has resolved with data that gets passed to the page.\"]\n      }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(LocalImage, {\n        src: \"/images/talks/advanced-rendering-patterns/34.png\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"One thing to keep in mind (and that's often the cause of a long \", _jsx(_components.code, {\n          children: \"getServerSideProps\"\n        }), \" execution), is the \", _jsx(Blue, {\n          children: \"time it takes to query data from your database\"\n        }), \".\"]\n      }), \"\\n\", _jsx(Video, {\n        src: \"Screen_Recording_2022-05-05_at_5.38.55_PM_uwecig\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"If your serverless function is deployed in San Francisco, but your database is deployed in Tokyo, it can take a while to establish a connection and get the data. Instead, consider \", _jsx(_components.strong, {\n          children: \"moving your database to the same region as your serverless function\"\n        }), \" to ensure your database queries can be a lot faster.\"]\n      }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(LocalImage, {\n        src: \"/images/talks/advanced-rendering-patterns/35.png\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Next, you might improve your performance a bit by \", _jsx(Blue, {\n          children: \"adding\"\n        }), \" \", _jsx(_components.code, {\n          children: \"Cache-Control\"\n        }), \" \", _jsx(Blue, {\n          children: \"headers\"\n        }), \" to the responses.\"]\n      }), \"\\n\", _jsx(LocalImage, {\n        src: \"/images/talks/advanced-rendering-patterns/36.png\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"However, if you find yourself doing that, your page might work even better if you used \", _jsx(_components.strong, {\n          children: \"(On-demand) Incremental Static Regeneration\"\n        }), \". Besides not having to manually take care of revalidation, the recomputed page will also be shared globally as opposed to one single region. \", _jsx(_components.strong, {\n          children: \"(On-demand) Incremental Static Regeneration\"\n        }), \" also ensures that your website is always online since there will \", _jsx(Blue, {\n          children: \"always be a cached version available\"\n        }), \", whereas \", _jsx(_components.strong, {\n          children: \"Server-Side Rendering\"\n        }), \" is \", _jsx(Blue, {\n          children: \"dependent on the availability of the lambda\"\n        }), \". If a region goes down, so does your website.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Since ISR does not allow you to use request-based data, \", _jsx(_components.strong, {\n          children: \"SSR\"\n        }), \" is still definitely the way to go if your page is using this.\"]\n      }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(LocalImage, {\n        src: \"/images/talks/advanced-rendering-patterns/37.png\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Next is something that is not as easy to do, namely \", _jsx(_components.strong, {\n          children: \"upgrading the server hardware\"\n        }), \" to get faster responses.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"When you deploy to Vercel, we use serverless functions to server-render your pages.\"\n      }), \"\\n\", _jsx(LocalImage, {\n        src: \"/images/talks/advanced-rendering-patterns/38.png\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Although serverless functions come with many benefits, such as only having to pay for what you use, there are a few limitations. A common issue is the \", _jsx(Blue, {\n          children: \"long cold boot\"\n        }), \", meaning the time it takes to start up the lambda, and \", _jsx(Blue, {\n          children: \"slow connections to databases\"\n        }), \". It’s also not great to call a serverless function all the way on the west coast if you’re located on the other side of the planet.\"]\n      }), \"\\n\", _jsx(LocalImage, {\n        src: \"/images/talks/advanced-rendering-patterns/39.png\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"We're currently exploring \", _jsx(_components.strong, {\n          children: \"Edge Server-Side Rendering\"\n        }), \", which enables users to \", _jsx(Blue, {\n          children: \"server-render from all regions\"\n        }), \", and experience a \", _jsx(Blue, {\n          children: \"near-zero cold boot\"\n        }), \". Another huge benefit of \", _jsx(_components.strong, {\n          children: \"Edge SSR\"\n        }), \", is the fact that the edge runtime also allows for \", _jsx(Blue, {\n          children: \"HTTP streaming\"\n        }), \".\"]\n      }), \"\\n\", _jsx(Video, {\n        src: \"Screen_Recording_2022-05-05_at_5.47.07_PM_usqexj\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"With serverless functions, we had to generate the entire page server-side, and \", _jsx(Blue, {\n          children: \"wait for the entire bundle\"\n        }), \" to be loaded and parsed on the client before hydration could begin.\"]\n      }), \"\\n\", _jsx(Video, {\n        src: \"Screen_Recording_2022-05-05_at_5.48.20_PM_auurip\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"With \", _jsx(_components.strong, {\n          children: \"Edge SSR\"\n        }), \", we can \", _jsx(Blue, {\n          children: \"stream parts of the document as soon as they're ready\"\n        }), \", and \", _jsx(Blue, {\n          children: \"hydrate these components granularly\"\n        }), \". This means that users no longer have to wait for a longer time before they can see anything on the screen, as the components stream in one by one.\"]\n      }), \"\\n\", _jsx(LocalImage, {\n        src: \"/images/talks/advanced-rendering-patterns/40.png\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.strong, {\n          children: \"Streaming SSR\"\n        }), \" also enables \", _jsx(_components.strong, {\n          children: \"React Server Components\"\n        }), \". Now I'm not going into the nitty gritty details of \", _jsx(_components.strong, {\n          children: \"React Server Components\"\n        }), \", but the combination of \", _jsx(_components.strong, {\n          children: \"Edge SSR with React Server Components\"\n        }), \" can allow us to have a beautiful \", _jsx(Blue, {\n          children: \"hybrid between static and server rendering\"\n        }), \".\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.strong, {\n          children: \"React Server Components\"\n        }), \" allow us to partially render React components on the server, which is especially useful for components that require large dependencies, as we no longer have to download these dependencies on the client.\"]\n      }), \"\\n\", _jsx(LocalImage, {\n        src: \"/images/talks/advanced-rendering-patterns/41.png\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"For example if we wanted to show the landing page again, but this time we wanted to show region-specific listings to the user. The vast majority of the page only contains static data, it's just the listings that require request-based data.\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Instead of having to server-render the entire page, we can now choose to \", _jsx(Blue, {\n          children: \"only render the listings component server-side\"\n        }), \", and the rest client-side. Whereas we initially had to server-render the entire page to achieve this behavior, we can now get the \", _jsx(Blue, {\n          children: \"great performance of\"\n        }), \" \", _jsx(_components.strong, {\n          children: \"Static Rendering\"\n        }), \" \", _jsx(Blue, {\n          children: \", with the dynamic benefits of\"\n        }), \" \", _jsx(_components.strong, {\n          children: \"Server-Side Rendering\"\n        }), \".\"]\n      }), \"\\n\", _jsx(LocalImage, {\n        src: \"/images/talks/advanced-rendering-patterns/42.png\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Although we've just covered many patterns to choose from, knowing which pattern makes the most sense for your use case can give your application huge performance benefits. On Vercel, you can opt into these techniques on a per-page basis, making it \", _jsx(Blue, {\n          children: \"extremely easy to scale without running into performance issues\"\n        }), \" when your application grows.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.strong, {\n          children: \"Static Rendering\"\n        }), \" and \", _jsx(_components.strong, {\n          children: \"Server Rendering\"\n        }), \" both have their place in the world, and we're working on a future where we we can create highly personalized websites with great performance. The web is extremely powerful, and it’s only getting better, especially with an Edge-first approach to look forward to!\"]\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\nfunction _missingMdxReference(id, component) {\n  throw new Error(\"Expected \" + (component ? \"component\" : \"object\") + \" `\" + id + \"` to be defined: you likely forgot to import, pass, or provide it.\");\n}\n","frontmatter":{},"scope":{"id":"rendering-patterns","title":"Talks | Rendering Patterns","hide_table_of_contents":false,"date":"May 6th, 2022","ogImage":"/images/talks/advanced-rendering-patterns/og.png","ogTitle":"Talks | Rendering Patterns","ogDescription":"Using the right rendering and fetching techniques can drastically improve your apps performance. Learn more about the rendering patterns, their use cases, and tradeoffs.","pathname":"/talks/rendering-patterns"}}},"__N_SSG":true},"page":"/[type]/[post]","query":{"type":"talks","post":"rendering-patterns"},"buildId":"GFd_W0mTx3KmMMLu9UgcV","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>